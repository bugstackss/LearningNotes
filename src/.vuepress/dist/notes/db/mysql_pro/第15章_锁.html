<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.53" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://Ragnarokoo.github.io/LearningNotes/notes/db/mysql_pro/%E7%AC%AC15%E7%AB%A0_%E9%94%81.html"><meta property="og:site_name" content="📚全栈开发学习指南"><meta property="og:title" content="第 15 章_锁"><meta property="og:description" content="事务的隔离性由这章讲述的锁来实现。 1. 概述 锁是计算机协调多个进程或线程并发访问某一资源的机制。在程序开发中会存在多线程同步的问题，当多个线程并发访问某个数据的时候，尤其是针对一些敏感的数据（比如订单、金额等），我们就需要保证这个数据在任何时刻最多只有一个线程在访问，保证数据的完整性和`一致性。在开发过程中加锁是为了保证数据的一致性，这个思想在数据..."><meta property="og:type" content="article"><meta property="og:image" content="https://Ragnarokoo.github.io/LearningNotes/"><meta property="og:updated_time" content="2023-05-31T09:16:41.000Z"><meta property="og:locale" content="zh-CN"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image:alt" content="第 15 章_锁"><meta property="article:tag" content="mysql"><meta property="article:tag" content="SQL"><meta property="article:tag" content="关系型数据库"><meta property="article:modified_time" content="2023-05-31T09:16:41.000Z"><link rel="icon" href="/site_logo.svg"><title>第 15 章_锁 | 📚全栈开发学习指南</title><meta name="description" content="事务的隔离性由这章讲述的锁来实现。 1. 概述 锁是计算机协调多个进程或线程并发访问某一资源的机制。在程序开发中会存在多线程同步的问题，当多个线程并发访问某个数据的时候，尤其是针对一些敏感的数据（比如订单、金额等），我们就需要保证这个数据在任何时刻最多只有一个线程在访问，保证数据的完整性和`一致性。在开发过程中加锁是为了保证数据的一致性，这个思想在数据...">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/assets/style.bc8b6d7c.css" as="style" /><link rel="stylesheet" href="/assets/style.bc8b6d7c.css" />
    <link rel="modulepreload" href="/assets/app.9b10ba0a.js"><link rel="modulepreload" href="/assets/第15章_锁.html.132f3832.js"><link rel="modulepreload" href="/assets/_plugin-vue_export-helper.cdc0426e.js"><link rel="modulepreload" href="/assets/第15章_锁.html.bab91902.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><!--[--><header class="navbar"><div class="navbar-left"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><a href="/" class="brand"><img class="logo" src="/site_logo.svg" alt="📚全栈开发学习指南"><!----><span class="site-name hide-in-pad">📚全栈开发学习指南</span></a><!--[--><!----><!--]--></div><div class="navbar-center"><!--[--><!----><!--]--><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/quicknav/" class="nav-link" aria-label="快速导航"><span class="icon iconfont icon-navigation"></span>快速导航<!----></a></div><div class="nav-item hide-in-mobile"><a href="/blog/" class="nav-link" aria-label="博客主页"><span class="icon iconfont icon-blog"></span>博客主页<!----></a></div><div class="nav-item hide-in-mobile"><a href="/notes/" class="nav-link active" aria-label="Java学习教程"><span class="icon iconfont icon-java"></span>Java学习教程<!----></a></div><div class="nav-item hide-in-mobile"><a href="/web/" class="nav-link" aria-label="web学习教程"><span class="icon iconfont icon-note"></span>web学习教程<!----></a></div><div class="nav-item hide-in-mobile"><a href="/springcloud/" class="nav-link" aria-label="SpringCloud学习教程"><span class="icon iconfont icon-cache"></span>SpringCloud学习教程<!----></a></div><div class="nav-item hide-in-mobile"><a href="/distributed/" class="nav-link" aria-label="分布式微服务架构"><span class="icon iconfont icon-read"></span>分布式微服务架构<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="资源宝库"><span class="title"><span class="icon iconfont icon-advance"></span>资源宝库</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/resources/books/" class="nav-link" aria-label="书籍资源"><span class="icon iconfont icon-animation"></span>书籍资源<!----></a></li><li class="dropdown-item"><a href="/resources/videos/" class="nav-link" aria-label="影音资源"><span class="icon iconfont icon-play"></span>影音资源<!----></a></li></ul></button></div></div></nav><!--[--><!----><!--]--></div><div class="navbar-right"><!--[--><!----><!--]--><!----><div class="nav-item"><a class="repo-link" href="https://github.com/Ragnarokoo/LearningNotes" target="_blank" rel="noopener noreferrer" aria-label="Github"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button class="outlook-button" tabindex="-1" ariahidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="outlook icon"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg><div class="outlook-dropdown"><!----></div></button></div><form class="search-box" role="search"><input type="search" placeholder="搜索本站" autocomplete="off" spellcheck="false" value><!----></form><!--[--><!----><!--]--><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="icon iconfont icon-java"></span><span class="title">Java Language专栏</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="icon iconfont icon-IO"></span><span class="title">Java网络编程NIO</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="icon iconfont icon-community"></span><span class="title">JDBC数据库连接技术</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="icon iconfont icon-categoryselected"></span><span class="title">JavaWeb</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="icon iconfont icon-array"></span><span class="title">SSM Framework</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="icon iconfont icon-geometry"></span><span class="title">SpringData</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="icon iconfont icon-type"></span><span class="title">SpringBoot</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="icon iconfont icon-module"></span><span class="title">mybatisplus</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="icon iconfont icon-operate"></span><span class="title">构建工具&amp;云原生Devops</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable active"><span class="icon iconfont icon-mysql"></span><span class="title">数据库以及调优策略</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="icon iconfont icon-mysql"></span><span class="title">MYSQL基础篇学习专栏</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable active"><span class="icon iconfont icon-mysql"></span><span class="title">MYSQL高级篇学习专栏</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><a href="/notes/db/mysql_pro/%E7%AC%AC01%E7%AB%A0_Linux%E4%B8%8BMySQL%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8.html" class="nav-link sidebar-link sidebar-page" aria-label="第 01 章_Linux下MySQL的安装与使用"><!---->第 01 章_Linux下MySQL的安装与使用<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/notes/db/mysql_pro/%E7%AC%AC%2002%20%E7%AB%A0_MySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95.html" class="nav-link sidebar-link sidebar-page" aria-label="第 02 章_MySQL的数据目录"><!---->第 02 章_MySQL的数据目录<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/notes/db/mysql_pro/%E7%AC%AC%2003%20%E7%AB%A0_%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86.html" class="nav-link sidebar-link sidebar-page" aria-label="第 03 章_用户与权限管理"><!---->第 03 章_用户与权限管理<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/notes/db/mysql_pro/%E7%AC%AC%2004%20%E7%AB%A0_%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84.html" class="nav-link sidebar-link sidebar-page" aria-label="第 04 章_逻辑架构"><!---->第 04 章_逻辑架构<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/notes/db/mysql_pro/%E7%AC%AC%2005%20%E7%AB%A0_%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html" class="nav-link sidebar-link sidebar-page" aria-label="第 05 章_存储引擎"><!---->第 05 章_存储引擎<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/notes/db/mysql_pro/%E7%AC%AC%2006%20%E7%AB%A0_%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html" class="nav-link sidebar-link sidebar-page" aria-label="第 06 章_索引的数据结构"><!---->第 06 章_索引的数据结构<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/notes/db/mysql_pro/%E7%AC%AC%2008%20%E7%AB%A0_%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99.html" class="nav-link sidebar-link sidebar-page" aria-label="第 08 章_索引的创建与设计原则"><!---->第 08 章_索引的创建与设计原则<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/notes/db/mysql_pro/%E7%AC%AC%2009%20%E7%AB%A0_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8.html" class="nav-link sidebar-link sidebar-page" aria-label="第 09 章_性能分析工具的使用"><!---->第 09 章_性能分析工具的使用<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/notes/db/mysql_pro/%E7%AC%AC%2010%20%E7%AB%A0_%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E4%B8%8E%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96.html" class="nav-link sidebar-link sidebar-page" aria-label="第 10 章_索引优化与查询优化"><!---->第 10 章_索引优化与查询优化<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/notes/db/mysql_pro/%E7%AC%AC11%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83.html" class="nav-link sidebar-link sidebar-page" aria-label="第11章_数据库的设计规范"><!---->第11章_数据库的设计规范<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/notes/db/mysql_pro/%E7%AC%AC12%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B6%E5%AE%83%E8%B0%83%E4%BC%98%E7%AD%96%E7%95%A5.html" class="nav-link sidebar-link sidebar-page" aria-label="第12章_数据库其它调优策略"><!---->第12章_数据库其它调优策略<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/notes/db/mysql_pro/%E7%AC%AC13%E7%AB%A0_%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html" class="nav-link sidebar-link sidebar-page" aria-label="第13章_事务基础知识"><!---->第13章_事务基础知识<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/notes/db/mysql_pro/%E7%AC%AC14%E7%AB%A0_MySQL%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97.html" class="nav-link sidebar-link sidebar-page" aria-label="第14章_MySQL事务日志"><!---->第14章_MySQL事务日志<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/notes/db/mysql_pro/%E7%AC%AC15%E7%AB%A0_%E9%94%81.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="第 15 章_锁"><!---->第 15 章_锁<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/notes/db/mysql_pro/%E7%AC%AC15%E7%AB%A0_%E9%94%81.html#_1-概述" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1. 概述"><!---->1. 概述<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/db/mysql_pro/%E7%AC%AC15%E7%AB%A0_%E9%94%81.html#_2-mysql并发事务访问相同记录" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2. MySQL并发事务访问相同记录"><!---->2. MySQL并发事务访问相同记录<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/notes/db/mysql_pro/%E7%AC%AC15%E7%AB%A0_%E9%94%81.html#_2-1-读-读情况" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2. 1 读-读情况"><!---->2. 1 读-读情况<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/db/mysql_pro/%E7%AC%AC15%E7%AB%A0_%E9%94%81.html#_2-2-写-写情况" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2. 2 写-写情况"><!---->2. 2 写-写情况<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/db/mysql_pro/%E7%AC%AC15%E7%AB%A0_%E9%94%81.html#_2-3-读-写或写-读情况" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2. 3 读-写或写-读情况"><!---->2. 3 读-写或写-读情况<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/db/mysql_pro/%E7%AC%AC15%E7%AB%A0_%E9%94%81.html#_2-4-并发问题的解决方案" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2. 4 并发问题的解决方案"><!---->2. 4 并发问题的解决方案<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/db/mysql_pro/%E7%AC%AC15%E7%AB%A0_%E9%94%81.html#_3-锁的不同角度分类" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3. 锁的不同角度分类"><!---->3. 锁的不同角度分类<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/notes/db/mysql_pro/%E7%AC%AC15%E7%AB%A0_%E9%94%81.html#_3-1-从数据操作的类型划分-读锁、写锁" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3. 1 从数据操作的类型划分：读锁、写锁"><!---->3. 1 从数据操作的类型划分：读锁、写锁<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/db/mysql_pro/%E7%AC%AC15%E7%AB%A0_%E9%94%81.html#_3-2-从数据操作的粒度划分-表级锁、页级锁、行锁" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.2 从数据操作的粒度划分：表级锁、页级锁、行锁"><!---->3.2 从数据操作的粒度划分：表级锁、页级锁、行锁<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/db/mysql_pro/%E7%AC%AC15%E7%AB%A0_%E9%94%81.html#_3-3-从对待锁的态度划分-乐观锁、悲观锁" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3. 3 从对待锁的态度划分:乐观锁、悲观锁"><!---->3. 3 从对待锁的态度划分:乐观锁、悲观锁<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/db/mysql_pro/%E7%AC%AC15%E7%AB%A0_%E9%94%81.html#_3-4-按加锁的方式划分-显式锁、隐式锁" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3. 4 按加锁的方式划分：显式锁、隐式锁"><!---->3. 4 按加锁的方式划分：显式锁、隐式锁<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/db/mysql_pro/%E7%AC%AC15%E7%AB%A0_%E9%94%81.html#即-一个事务对新插入的记录可以不显式的加锁-生成一个锁结构-但是由于事务id的存在-相当于加了一个隐式锁。别的事务在对这条记录加s锁或者x锁时-由于隐式锁的存在-会先帮助当前事务生成一个锁结构-然后自己再生成一个锁结构后进入等待状态。隐式锁是一种延迟加锁的机制-从而来减少加锁的数量。" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="即：一个事务对新插入的记录可以不显式的加锁（生成一个锁结构），但是由于事务id的存在，相当于加了一个隐式锁。别的事务在对这条记录加S锁或者X锁时，由于隐式锁的存在，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构后进入等待状态。隐式锁是一种延迟加锁的机制，从而来减少加锁的数量。"><!---->即：一个事务对新插入的记录可以不显式的加锁（生成一个锁结构），但是由于事务id的存在，相当于加了一个隐式锁。别的事务在对这条记录加S锁或者X锁时，由于隐式锁的存在，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构后进入等待状态。隐式锁是一种延迟加锁的机制，从而来减少加锁的数量。<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/notes/db/mysql_pro/%E7%AC%AC15%E7%AB%A0_%E9%94%81.html#_3-5-其它锁之-全局锁" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3. 5 其它锁之：全局锁"><!---->3. 5 其它锁之：全局锁<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/db/mysql_pro/%E7%AC%AC15%E7%AB%A0_%E9%94%81.html#_3-6-其它锁之-死锁" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3. 6 其它锁之：死锁"><!---->3. 6 其它锁之：死锁<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/db/mysql_pro/%E7%AC%AC15%E7%AB%A0_%E9%94%81.html#_4-锁的内存结构" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4. 锁的内存结构"><!---->4. 锁的内存结构<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/db/mysql_pro/%E7%AC%AC15%E7%AB%A0_%E9%94%81.html#_5-锁监控" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5. 锁监控"><!---->5. 锁监控<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/notes/db/mysql_pro/%E7%AC%AC15%E7%AB%A0_%E9%94%81.html#_6-附录" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6. 附录"><!---->6. 附录<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a href="/notes/db/mysql_pro/%E7%AC%AC16%E7%AB%A0_%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6.html" class="nav-link sidebar-link sidebar-page" aria-label="第 16 章_多版本并发控制"><!---->第 16 章_多版本并发控制<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/notes/db/mysql_pro/%E7%AC%AC17%E7%AB%A0_%E5%85%B6%E5%AE%83%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E5%BF%97.html" class="nav-link sidebar-link sidebar-page" aria-label="第17章_其他数据库日志"><!---->第17章_其他数据库日志<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/notes/db/mysql_pro/%E7%AC%AC18%E7%AB%A0_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.html" class="nav-link sidebar-link sidebar-page" aria-label="第 18 章_主从复制"><!---->第 18 章_主从复制<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/notes/db/mysql_pro/%E7%AC%AC19%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D.html" class="nav-link sidebar-link sidebar-page" aria-label="第19章_数据库备份与恢复"><!---->第19章_数据库备份与恢复<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="icon iconfont icon-workingDirectory"></span><span class="title">Redis入门到精通</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="icon iconfont icon-workingDirectory"></span><span class="title">Redis大厂进阶篇</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="icon iconfont icon-free"></span><span class="title">数据库优化策略</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="icon iconfont icon-search"></span><span class="title">Elasticsearch7.x分布式搜索引擎</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="icon iconfont icon-search"></span><span class="title">Elasticsearch8.x分布式搜索引擎</span><span class="arrow right"></span></button><!----></section></li></ul></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="icon iconfont icon-quote"></span><span class="title">消息中间件</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="icon iconfont icon-tool"></span><span class="title">软件以及环境配置</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="icon iconfont icon-ability"></span><span class="title">Linux操作系统</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="icon iconfont icon-rank"></span><span class="title">JUC高并发编程</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="icon iconfont icon-mount"></span><span class="title">深入了解Java虚拟机</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="icon iconfont icon-view"></span><span class="title">GOF23种设计模式</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="icon iconfont icon-tag"></span><span class="title">技术要点业务篇</span><span class="arrow right"></span></button><!----></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->第 15 章_锁</h1><div class="page-info"><span class="category-info" aria-label="分类🌈" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><ul class="categories-wrapper"><li><span class="category category4 clickable" role="navigation">mysql</span></li></ul><meta property="articleSection" content="mysql"></span><span aria-label="标签🏷" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon tag-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="tag icon"><path d="M939.902 458.563L910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 000 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z"></path></svg><ul class="tags-wrapper"><li><span class="tag tag4 clickable" role="navigation">mysql</span></li><li><span class="tag tag3 clickable" role="navigation">SQL</span></li><li><span class="tag tag0 clickable" role="navigation">关系型数据库</span></li></ul><meta property="keywords" content="mysql,SQL,关系型数据库"></span><span class="reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 82 分钟</span><meta property="timeRequired" content="PT82M"></span><span class="author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="author-item" href="https://github.com/Ragnarokoo/" target="_blank" rel="noopener noreferrer">Ragnarok</a></span><span property="author" content="Ragnarok"></span></span><span class="date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2023-05-31T09:16:41.000Z"></span></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/notes/db/mysql_pro/%E7%AC%AC15%E7%AB%A0_%E9%94%81.html#_1-概述" class="router-link-active router-link-exact-active toc-link level2">1. 概述</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/db/mysql_pro/%E7%AC%AC15%E7%AB%A0_%E9%94%81.html#_2-mysql并发事务访问相同记录" class="router-link-active router-link-exact-active toc-link level2">2. MySQL并发事务访问相同记录</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/notes/db/mysql_pro/%E7%AC%AC15%E7%AB%A0_%E9%94%81.html#_2-1-读-读情况" class="router-link-active router-link-exact-active toc-link level3">2. 1 读-读情况</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/db/mysql_pro/%E7%AC%AC15%E7%AB%A0_%E9%94%81.html#_2-2-写-写情况" class="router-link-active router-link-exact-active toc-link level3">2. 2 写-写情况</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/db/mysql_pro/%E7%AC%AC15%E7%AB%A0_%E9%94%81.html#_2-3-读-写或写-读情况" class="router-link-active router-link-exact-active toc-link level3">2. 3 读-写或写-读情况</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/db/mysql_pro/%E7%AC%AC15%E7%AB%A0_%E9%94%81.html#_2-4-并发问题的解决方案" class="router-link-active router-link-exact-active toc-link level3">2. 4 并发问题的解决方案</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/db/mysql_pro/%E7%AC%AC15%E7%AB%A0_%E9%94%81.html#_3-锁的不同角度分类" class="router-link-active router-link-exact-active toc-link level2">3. 锁的不同角度分类</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/notes/db/mysql_pro/%E7%AC%AC15%E7%AB%A0_%E9%94%81.html#_3-1-从数据操作的类型划分-读锁、写锁" class="router-link-active router-link-exact-active toc-link level3">3. 1 从数据操作的类型划分：读锁、写锁</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/db/mysql_pro/%E7%AC%AC15%E7%AB%A0_%E9%94%81.html#_3-2-从数据操作的粒度划分-表级锁、页级锁、行锁" class="router-link-active router-link-exact-active toc-link level3">3.2 从数据操作的粒度划分：表级锁、页级锁、行锁</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/db/mysql_pro/%E7%AC%AC15%E7%AB%A0_%E9%94%81.html#_3-3-从对待锁的态度划分-乐观锁、悲观锁" class="router-link-active router-link-exact-active toc-link level3">3. 3 从对待锁的态度划分:乐观锁、悲观锁</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/db/mysql_pro/%E7%AC%AC15%E7%AB%A0_%E9%94%81.html#_3-4-按加锁的方式划分-显式锁、隐式锁" class="router-link-active router-link-exact-active toc-link level3">3. 4 按加锁的方式划分：显式锁、隐式锁</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/db/mysql_pro/%E7%AC%AC15%E7%AB%A0_%E9%94%81.html#即-一个事务对新插入的记录可以不显式的加锁-生成一个锁结构-但是由于事务id的存在-相当于加了一个隐式锁。别的事务在对这条记录加s锁或者x锁时-由于隐式锁的存在-会先帮助当前事务生成一个锁结构-然后自己再生成一个锁结构后进入等待状态。隐式锁是一种延迟加锁的机制-从而来减少加锁的数量。" class="router-link-active router-link-exact-active toc-link level2">即：一个事务对新插入的记录可以不显式的加锁（生成一个锁结构），但是由于事务id的存在，相当于加了一个隐式锁。别的事务在对这条记录加S锁或者X锁时，由于隐式锁的存在，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构后进入等待状态。隐式锁是一种延迟加锁的机制，从而来减少加锁的数量。</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/notes/db/mysql_pro/%E7%AC%AC15%E7%AB%A0_%E9%94%81.html#_3-5-其它锁之-全局锁" class="router-link-active router-link-exact-active toc-link level3">3. 5 其它锁之：全局锁</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/db/mysql_pro/%E7%AC%AC15%E7%AB%A0_%E9%94%81.html#_3-6-其它锁之-死锁" class="router-link-active router-link-exact-active toc-link level3">3. 6 其它锁之：死锁</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/db/mysql_pro/%E7%AC%AC15%E7%AB%A0_%E9%94%81.html#_4-锁的内存结构" class="router-link-active router-link-exact-active toc-link level2">4. 锁的内存结构</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/db/mysql_pro/%E7%AC%AC15%E7%AB%A0_%E9%94%81.html#_5-锁监控" class="router-link-active router-link-exact-active toc-link level2">5. 锁监控</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/notes/db/mysql_pro/%E7%AC%AC15%E7%AB%A0_%E9%94%81.html#_6-附录" class="router-link-active router-link-exact-active toc-link level2">6. 附录</a></li><!----><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><h1 id="第-15-章-锁" tabindex="-1"><a class="header-anchor" href="#第-15-章-锁" aria-hidden="true">#</a> 第 15 章_锁</h1><p>事务的<code>隔离性</code>由这章讲述的<code>锁</code>来实现。</p><h2 id="_1-概述" tabindex="-1"><a class="header-anchor" href="#_1-概述" aria-hidden="true">#</a> 1. 概述</h2><p><code>锁</code>是计算机协调多个进程或线程<code>并发访问某一资源</code>的机制。在程序开发中会存在多线程同步的问题，当多个线程并发访问某个数据的时候，尤其是针对一些敏感的数据（比如订单、金额等），我们就需要保证这个数据在任何时刻<code>最多只有一个线程</code>在访问，保证数据的<code>完整性</code>和<code>一致性</code>。在开发过程中加锁是为了保证数据的一致性，这个思想在数据库领域中同样很重要。</p><p>在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。为保证数据的一致性，需要对<code>并发操作进行控制</code>，因此产生了<code>锁</code>。同时<code>锁机制</code>也为实现MySQL的各个隔离级别提供了保证。<code>锁冲突</code>也是影响数据库<code>并发访问性能</code>的一个重要因素。所以锁对数据库而言显得尤其重要，也更加复杂。</p><h2 id="_2-mysql并发事务访问相同记录" tabindex="-1"><a class="header-anchor" href="#_2-mysql并发事务访问相同记录" aria-hidden="true">#</a> 2. MySQL并发事务访问相同记录</h2><p>并发事务访问相同记录的情况大致可以划分为 3 种：</p><h3 id="_2-1-读-读情况" tabindex="-1"><a class="header-anchor" href="#_2-1-读-读情况" aria-hidden="true">#</a> 2. 1 读-读情况</h3><p><code>读-读</code>情况，即并发事务相继<code>读取相同的记录</code>。读取操作本身不会对记录有任何影响，并不会引起什么问题，所以允许这种情况的发生。</p><h3 id="_2-2-写-写情况" tabindex="-1"><a class="header-anchor" href="#_2-2-写-写情况" aria-hidden="true">#</a> 2. 2 写-写情况</h3><p><code>写-写</code>情况，即并发事务相继对相同的记录做出改动。</p><p>在这种情况下会发生<code>脏写</code>的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们<code>排队执行</code>，这个排队的过程其实是通过锁来实现的。这个所谓的锁其实是一个<code>内存中的结构</code>，在事务执行前本来是没有锁的，也就是说一开始是没有<code>锁结构</code>和记录进行关联的，如图所示：</p><p><img src="/assets/d4c6c0d35d87e0da40ef4cc072267e51.837c95e5.png" alt="image-20230123203920264"></p><p>当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的<code>锁结构</code>，当没有的时候就会在内存中生成一个<code>锁结构</code>与之关联。比如，事务<code>T1</code>要对这条记录做改动，就需要生成一个<code>锁结构</code>与之关联：</p><p><img src="/assets/14a35c87ca96ac0b3327cc0c9c23797a.d029aa34.png" alt="image-20230123203950048"></p><p>在锁结构里有很多信息，为了简化理解，只把两个比较重要的属性拿了出来:</p><ul><li><p><code>trx信息</code>:代表这个锁结构是哪个事务生成的。</p></li><li><p><code>is_waiting</code> :代表当前事务是否在等待。</p></li></ul><p>当事务<code>T1</code>改动了这条记录后，就生成了一个<code>锁结构</code>与该记录关联，因为之前没有别的事务为这条记录加锁，所以<code>is_waiting</code>属性就是<code>false</code>，我们把这个场景就称之为<code>获取锁成功</code>，或者<code>加锁成功</code>，然后就可以继续执行操作了。</p><p>在事务<code>T1</code>提交之前，另一个事务<code>T2</code>也想对该记录做改动，那么先看看有没有锁结构与这条记录关联，发现有一个锁结构与之关联后，然后也生成了一个锁结构与这条记录关联，不过锁结构的<code>is_waiting</code>属性值为<code>true</code> ,表示当前事务需要等待，我们把这个场景就称之为<code>获取锁失</code>败，或者<code>加锁失败</code>，图示:</p><p><img src="/assets/f08a87dd7219d1c9f64a582a175ecab7.8367e66c.png" alt="image-20230123204057637"></p><p>在事务T1提交之后，就会把该事务生成的<code>锁结构释放</code>掉，然后看看还有没有别的事务在等待获取锁，发现了事务T2还在等待获取锁，所以把事务T2对应的锁结构的<code>is_waiting</code>属性设置为<code>false</code>，然后把该事务对应的线程唤醒，让它继续执行，此时事务T2就算获取到锁了。效果图就是这样:</p><p><img src="/assets/6f526dd11152170d71725b4741b2d9b5.358be039.png" alt="image-20230123204129603"></p><p>小结几种说法：</p><ul><li><p>不加锁</p><p>意思就是不需要在内存中生成对应的<code>锁结构</code>，可以直接执行操作。</p></li><li><p>获取锁成功，或者加锁成功</p><p>意思就是在内存中生成了对应的<code>锁结构</code>，而且锁结构的<code>is_waiting</code>属性为<code>false</code>，也就是事务 可以继续执行操作。</p></li><li><p>获取锁失败，或者加锁失败，或者没有获取到锁</p><p>意思就是在内存中生成了对应的锁结构，不过锁结构的<code>is_waiting</code>属性为<code>true</code>，也就是事务 需要等待，不可以继续执行操作。</p></li></ul><h3 id="_2-3-读-写或写-读情况" tabindex="-1"><a class="header-anchor" href="#_2-3-读-写或写-读情况" aria-hidden="true">#</a> 2. 3 读-写或写-读情况</h3><p><code>读-写</code>或<code>写-读</code>，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>的问题。</p><p>各个数据库厂商对<code>SQL标准的</code>支持都可能不一样。比如MySQL在<code>REPEATABLE READ</code>隔离级别上就已经解决了幻读问题。</p><h3 id="_2-4-并发问题的解决方案" tabindex="-1"><a class="header-anchor" href="#_2-4-并发问题的解决方案" aria-hidden="true">#</a> 2. 4 并发问题的解决方案</h3><p>怎么解决<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>这些问题呢？其实有两种可选的解决方案：</p><ul><li>方案一：读操作利用多版本并发控制（MVCC，下章讲解），写操作进行加锁。</li></ul><p>所谓的<code>MVCC</code>，就是生成一个<code>ReadView</code>，通过ReadView找到符合条件的记录版本（历史版本由<code>undo日志</code>构建)。查询语句只能<code>读</code>到在生成ReadView之前<code>已提交事务所做的更改</code>，在生成ReadView之前未提交的事务或者之后才开启的事务所做的更改是看不到的。而<code>写操作</code>肯定针对的是<code>最新版本的记</code>录，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用MVCC时，<code>读-写</code>操作并不冲突。</p><blockquote><p>普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录。</p><ul><li><p>在<code>READ COMMITTED</code>隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一个ReadView，ReadView的存在本身就保证了<code>事务不可以读取到未提交的事务所做的更改</code>，也就是避免了脏读现象；</p></li><li><p>在<code>REPEATABLE READ</code>隔离级别下，一个事务在执行过程中只有第一次执行SELECT操作才会生成一个ReadView，之后的SELECT操作都<code>复用</code>这个ReadView，这样也就避免了不可重复读和幻读的问题。</p><p>tips: 这里幻读没解决吧!!!!!</p></li></ul></blockquote><ul><li><p>方案二：读、写操作都采用<code>加锁</code>的方式。</p><p>如果我们的一些业务场景不允许读取记录的旧版本，而是每次都必须去<code>读取记录的最新版本</code>。比如，在银行存款的事务中，你需要先把账户的余额读出来，然后将其加上本次存款的数额最后再写到数据库中。在将账户余额读取出来后，就不想让别的事务再访问该余额，直到本次存款事务执行完成，其他事务才可以访问账户的余额。这样在读取记录的时候就需要对其进行<code>加锁</code>操作，这样也就意味着<code>读</code>操作和<code>写</code>操作也像<code>写-写</code>操作那样<code>排队</code>执行。</p><p><code>脏读</code>的产生是因为当前事务读取了另一个未提交事务写的一条记录，如果另一个事务在写记录的时候就给这条记录加锁，那么当前事务就无法继续读取该记录了，所以也就不会有脏读问题的产生了。</p><p><code>不可重复读</code>的产生是因为当前事务先读取一条记录，另外一个事务对该记录做了改动之后并提交之后，当前事务再次读取时会获得不同的值，如果在当前事务读取记录时就给该记录加锁那么另一个事务就无法修改该记录，自然也不会发生不可重复读了。</p><p><code>幻读</code>问题的产生是因为当前事务读取了一个范围的记录，然后另外的事务向该范围内插入了新记录，当前事务再次读取该范围的记录时发现了新插入的新记录。采用加锁的方式解决幻读问题就有一些麻烦，因为当前事务在第一次读取记录时幻影记录并不存在，所以读取的时候加锁就有点尴尬（因为你并不知道给谁加锁)。</p></li><li><p>小结对比发现：</p><ul><li>采用<code>MVCC</code>方式的话，<code>读-写</code>操作彼此并不冲突，<code>性能更高</code>。</li><li>采用<code>加锁</code>方式的话，<code>读-写</code>操作彼此需要<code>排队执行</code>，影响性能。</li></ul><p>一般情况下我们当然愿意采用<code>MVCC</code>来解决<code>读-写</code>操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用<code>加锁</code>的方式执行。下面就讲解下MySQL中不同类别的锁。</p></li></ul><h2 id="_3-锁的不同角度分类" tabindex="-1"><a class="header-anchor" href="#_3-锁的不同角度分类" aria-hidden="true">#</a> 3. 锁的不同角度分类</h2><p>锁的分类图，如下：</p><p><img src="/assets/9470a24d03330813a670cdd85385c339.02c55952.png" alt="image-20230123212838138"></p><h3 id="_3-1-从数据操作的类型划分-读锁、写锁" tabindex="-1"><a class="header-anchor" href="#_3-1-从数据操作的类型划分-读锁、写锁" aria-hidden="true">#</a> 3. 1 从数据操作的类型划分：读锁、写锁</h3><p>对于数据库中并发事务的<code>读-读</code>情况并不会引起什么问题。对于<code>写-写</code>、<code>读-写</code>或<code>写-读</code>这些情况可能会引起一些问题，需要使用<code>MVCC</code>或者<code>加锁</code>的方式来解决它们。在使用<code>加锁</code>的方式解决问题时，由于既要允许<code>读-读</code>情况不受影响，又要使<code>写-写</code>、<code>读-写</code>或写-读情况中的操作相互阻塞，所以MySQL实现一个由两种类型的锁组成的锁系统来解决。这两种类型的锁通常被称为**共享锁(Shared Lock，SLock)<strong>和</strong>排他锁(Exclusive Lock，XLock),**也叫读锁(readlock)和写锁(write lock)。</p><ul><li><p><code>读锁</code>：也称为<code>共享锁</code>、英文用<code>S</code>表示。针对同一份数据，多个事务的读操作可以同时进行而不会互相影响，相互不阻塞的。</p></li><li><p><code>写锁</code>：也称为<code>排他锁</code>、英文用<code>X</code>表示。当前写操作没有完成前，它会阻断其他写锁和读锁。这样就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。</p></li></ul><blockquote><p><strong>需要注意的是对于 InnoDB 引擎来说，读锁和写锁可以加在表上，也可以加在行上。</strong></p></blockquote><p><strong>举例(行级读写锁)∶</strong>如果一个事务T1已经获得了某个行r的读锁，那么此时另外的一个事务T2是可以去获得这个行r的读锁的，因为读取操作并没有改变行r的数据;但是，如果某个事务T3想获得行r的写锁，则它必须等待事务T1、T2释放掉行r上的读锁才行。</p><p>总结:这里的兼容是指对同一张表或记录的锁的兼容性情况。</p><table><thead><tr><th style="text-align:center;">兼容情况</th><th style="text-align:center;">X锁</th><th style="text-align:center;">S锁</th></tr></thead><tbody><tr><td style="text-align:center;">X锁</td><td style="text-align:center;">不兼容</td><td style="text-align:center;">不兼容</td></tr><tr><td style="text-align:center;">S锁</td><td style="text-align:center;">不兼容</td><td style="text-align:center;"><strong>兼容</strong></td></tr></tbody></table><h4 id="_1-锁定读" tabindex="-1"><a class="header-anchor" href="#_1-锁定读" aria-hidden="true">#</a> 1. 锁定读</h4><p>在采用<code>加锁</code>方式解决脏读、不可重复读、幻读这些问题时，读取一条记录时需要获取该记录的S锁，其实是不严谨的，有时候需要在读取记录时就获取记录的X锁，来禁止别的事务读写该记录，为此MySQL提出了两种比较特殊的SELECT语句格式:</p><ul><li>对读取的记录加S锁:</li></ul><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>SELECT ... LOCK IN SHARE MODE;
#或
SELECT ... FOR SHARE;#(8.0新增语法)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在普通的SELECT语句后边加<code>LOCK IN SHARE MODE</code>，如果当前事务执行了该语句，那么它会为读取到的记录加S锁，这样允许别的事务继续获取这些记录的S锁(比方说别的事务也使用<code>SELECT ... LOCK IN SHAREMODE</code>语句来读取这些记录)，但是不能获取这些记录的X锁(比如使用<code>SELECT ... FOR UPDATE</code>语句来读取这些记录，或者直接修改这些记录)。如果别的事务想要获取这些记录的<code>x锁</code>，那么它们会阻塞，直到当前事务提交之后将这些记录上的<code>S锁</code>释放掉。</p><ul><li>对读取的记录加X锁:</li></ul><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>SELECT ... FOR UPDATE;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在普通的SELECT语句后边加<code>FOR UPDATE</code>，如果当前事务执行了该语句，那么它会为读取到的记录加<code>X锁</code>，这样既不允许别的事务获取这些记录的S锁(比方说别的事务使用<code>SELECT ... LOCK IN SHARE MODE</code>语句来读取这些记录)，也不允许获取这些记录的X锁(比如使用<code>SELECT ... FOR UPDATE</code>语句来读取这些记录，或者直接修改这些记录)。如果别的事务想要获取这些记录的s锁或者X锁，那么它们会阻塞，直到当前事务提交之后将这些记录上的X锁释放掉。</p><p><strong>案例演示</strong></p><ul><li>S-&gt;S</li></ul><p><img src="/assets/f838f81f0cb935c559bda0fed4da8836.7788a283.png" alt="img"></p><ul><li>S-&gt;X</li></ul><p><img src="/assets/f86df713b8217ab3e83a188b886cdf79.f47a6f58.png" alt="img"></p><ul><li>X-&gt;S</li></ul><p><img src="/assets/a265eb6eabbf896da353c6dd6d2ac0e8.73d0568b.png" alt="img"></p><ul><li>X-&gt;X</li></ul><p><img src="/assets/fe6a882b8efef7ba35f5e36d38696d2c.3aa012e6.png" alt="img"></p><p><strong>MySQL8.0新特性:</strong></p><p>在5.7及之前的版本，SELECT ..FOR UPDATE，如果获取不到锁，会一直等待，直到<code>innodb_lock_wait_timeout</code>超时。在8.0版本中，SELECT. FOR UPDATE，SELECT ...FOR SHARE添加<code>NOWAIT</code>、<code>SKIP LOCKED</code>语法，跳过锁等待，或者跳过锁定。</p><ul><li>通过添加NOWAIT、SKIP LOCKED语法，能够立即返回。如果查询的行已经加锁: <ul><li>那么NOWAIT会立即报错返回（等不到锁立即返回）</li><li>而SKIP LOCKED也会立即返回，只是返回的结果中不包含被锁定的行。</li></ul></li></ul><p><strong>演示</strong></p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>#事务A
begin ;
select * from account for update;
/*
+-- --+--------+- ------ +
| id  |    NAME|  balance|
|   1 │     张三|    40.00|
|   2 |     李四|    0.00 |
|   3 |     王五|   100.00|
+--- -+--------+- ------ +
*/

#事务B
begin ;
select * from account for update nowait;
#报错返回
#ERROR 3572 (HYO00): Statement aborted because lock(s) could not be acquired immediately and NOMAIT is set.

select * from account for update skip locked;
# 因为事务A获得X锁，所以查到的记录是空的~
Empty set (o.00 sec)
commit;
#Query Ok,o rows affected ( sec)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-写操作" tabindex="-1"><a class="header-anchor" href="#_2-写操作" aria-hidden="true">#</a> 2.写操作</h4><p>平常所用到的<code>写操作</code>无非是<code>DELETE</code>、<code>UPDATE</code>、<code>INSERT</code>这三种:</p><ul><li><p>DELETE: 对一条记录做DELETE操作的过程其实是先在<code>B+</code>树中定位到这条记录的位置，然后获取这条记录的<code>X锁</code>，再执行<code>delete mark</code>.操作。我们也可以把这个定位待删除记录在B+树中位置的过程看成是一个获取<code>X锁</code>的<code>锁定读</code>。</p></li><li><p>UPDATE∶在对一条记录做UPDATE操作时分为三种情况:</p><ul><li><p>情况1: 未修改该记录的<code>键值</code>，并且被更新的列占用的存储空间在修改前后<code>未发生变化</code>。</p><p>则先在<code>B+</code>树中定位到这条记录的位置，然后再获取一下记录的<code>X锁</code>，最后在原记录的位置进行修改操作。我们也可以把这个定位待修改记录在B+树中位置的过程看成是一个获取<code>X锁</code>的<code>锁定读</code>。</p></li><li><p>情况2∶未修改该记录的<code>键值</code>，并且至少有一个被更新的列占用的存储空间在修改前后发生变化。</p><p>则先在B+树中定位到这条记录的位置，然后获取一下记录的X锁，将该记录彻底删除掉（就是把记录彻底移入垃圾链表)，最后再插入一条新记录。这个定位待修改记录在B+树中位置的过程看成是一个获取<code>×锁</code>的<code>锁定读</code>，新插入的记录由<code>INSERT</code>操作提供的<code>隐式锁</code>进行保护。</p></li><li><p>情况3∶修改了该记录的键值，则相当于在原记录上做DELETE操作之后再来一次INSERT操作，加锁操作就需要按照<code>DELETE</code>和<code>INSERT</code>的规则进行了。</p></li></ul></li><li><p>INSERT :</p></li><li><p>一般情况下，新插入一条记录的操作并不加锁，通过一种称之为<code>隐式锁</code>的结构来保护这条新插入的记录在本事务<code>提交前不被别的事务访问</code>。</p></li></ul><blockquote><p>分析：因为插入之前就没有要锁的记录，所以也就不需要加X锁了</p></blockquote><h3 id="_3-2-从数据操作的粒度划分-表级锁、页级锁、行锁" tabindex="-1"><a class="header-anchor" href="#_3-2-从数据操作的粒度划分-表级锁、页级锁、行锁" aria-hidden="true">#</a> 3.2 从数据操作的粒度划分：表级锁、页级锁、行锁</h3><p>为了尽可能提高数据库的并发度，每次锁定的数据范围越小越好，理论上每次只锁定当前操作的数据的方案会得到最大的并发度，但是管理锁是很<code>耗资源</code>的事情（涉及获取、检查、释放锁等动作)(越小消耗越大)。因此数据库系统需要在<code>高并响应</code>和<code>系统性能</code>两方面进行平衡，这样就产生了“<code>锁粒度(Lock granularity)</code>”的概念。</p><p>对一条记录加锁影响的也只是这条记录而已，我们就说这个锁的粒度比较细;其实一个事务也可以在<code>表级别</code>进行加锁，自然就被称之为<code>表级锁</code>或者<code>表锁</code>，对一个表加锁影响整个表中的记录，我们就说这个锁的粒度比较粗。锁的粒度主要分为表级锁、页级锁和行锁。</p><h4 id="_1-表锁-table-lock" tabindex="-1"><a class="header-anchor" href="#_1-表锁-table-lock" aria-hidden="true">#</a> 1.表锁（Table Lock）</h4><p>该锁会锁定整张表，它是MySQL中最基本的锁策略，<code>并不依赖于存储引擎</code>(不管你是MySQL的什么存储引擎，对于表锁的策略都是一样的)，并且表锁是<code>开销最小</code>的策略（因为粒度比较大)。由于表级锁一次会将整个表锁定，所以可以很好的<code>避免死锁</code>问题。当然，锁的粒度大所带来最大的负面影响就是出现锁资源争用的概率也会最高，导致<code>并发率大打折扣</code>。</p><h5 id="_1-表级别的s锁、x锁" tabindex="-1"><a class="header-anchor" href="#_1-表级别的s锁、x锁" aria-hidden="true">#</a> <strong>① 表级别的S锁、X锁</strong></h5><p>在对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，InnoDB存储引擎是不会为这个表添加表级别的<code>S锁</code>或者<code>X锁</code>的。在对某个表执行一些诸如<code>ALTER TABLE</code>、<code>DROP TABLE</code>这类的<code>DDL</code>语句时，其他事务对这个表并发执行诸如SELECT、INSERT、DELETE、UPDATE的语句会发生阻塞。同理，某个事务中对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，在其他会话中对这个表执行<code>DDL</code>语句也会发生阻塞。这个过程其实是通过在server层使用一种称之为<code>元数据锁</code>（英文名：<code>Metadata Locks</code>，简称<code>MDL</code>）结构来实现的。</p><p>一般情况下，不会使用InnoDB存储引擎提供的<code>表级别</code>的<code>S锁</code>和<code>X锁</code>。只会在一些特殊情况下，比方说<code>崩溃恢复</code>过程中用到。比如，在系统变量<code>autocommit=0，innodb_table_locks = 1</code>时，手动获取InnoDB存储引擎提供的表t 的S锁或者X锁可以这么写：</p><ul><li><code>LOCK TABLES t READ</code>：InnoDB存储引擎会对表t加表级别的S锁。</li><li><code>LOCK TABLES t WRITE</code>：InnoDB存储引擎会对表t加表级别的X锁。</li></ul><p>不过尽量避免在使用InnoDB存储引擎的表上使用<code>LOCK TABLES</code>这样的手动锁表语句，它们并不会提供什么额外的保护，只是会降低并发能力而已。InnoDB的厉害之处还是实现了更细粒度的行锁，关于InnoDB表级别的S锁和X锁大家了解一下就可以了。</p><p><strong>举例：</strong> 下面我们讲解MylSAM引擎下的表锁。</p><ul><li>步骤1：创建表并添加数据</li></ul><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>CREATE TABLE mylock(
id INT NOT NULL PRIMARY KEY auto_increment,NAME VARCHAR(20)
)ENGINE myisam;#存储引擎使用InnoDB也可以，只是不建议

#插入一条数据
INSERT INTO mylock(NAME) VALUES(&#39;a&#39;);

#查询表中所有的数据
SELECT * FROM mylock;
/*
+----+------+
| id | NAME |
+----+------+
|  1 | a    |
+----+------+
*/
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>步骤2：查看表上加过的锁</li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SHOW</span> <span class="token keyword">OPEN</span> <span class="token keyword">TABLES</span> <span class="token keyword">where</span> In_use <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token comment">#或者</span>
<span class="token keyword">SHOW</span> <span class="token keyword">OPEN</span> <span class="token keyword">TABLES</span><span class="token punctuation">;</span><span class="token comment">#主要关注In_use字段的值 &gt;0</span>
<span class="token comment">/*部分输出
SHOW OPEN TABLES;
+--------------------+---------------------------+--------+-------------+
| Database           | Table                     | In_use | Name_locked |
+--------------------+---------------------------+--------+-------------+
| atguigudb3         | user1                     |      0 |           0 |
| mysql              | tablespace_files          |      0 |           0 |
| mysql              | column_statistics         |      0 |           0 |
| atguigudb3         | account                   |      0 |           0 |
| mysql              | table_stats               |      0 |           0 |
| mysql              | check_constraints         |      0 |           0 |
| mysql              | view_table_usage          |      0 |           0 |
| mysql              | tables_priv               |      0 |           0 |
| mysql              | column_type_elements      |      0 |           0 |
| mysql              | foreign_key_column_usage  |      0 |           0 |
| mysql              | time_zone_name            |      0 |           0 |
.........................................................................
| information_schema | TABLES                    |      0 |           0 |
| mysql              | time_zone_transition_type |      0 |           0 |
| mysql              | tablespaces               |      0 |           0 |
+--------------------+---------------------------+--------+-------------+
61 rows in set (0.01 sec)                
*/</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>上面的结果表明，当前数据库中没有被锁定的表。</p></blockquote><ul><li>步骤3：手动增加表锁命令</li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">LOCK</span> <span class="token keyword">TABLES</span> t <span class="token keyword">READ</span>:<span class="token comment">#存储引擎会对表t加表级别的共享锁。共享锁也叫读锁或S锁(Share的缩写)</span>
<span class="token keyword">LOCK</span> <span class="token keyword">TABLES</span> t <span class="token keyword">WRITE</span>:<span class="token comment">#存储引擎会对表t加表级别的排他锁。排它锁也叫独占锁、写锁或X锁(是eXclusive的缩写)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>比如：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>mysql<span class="token operator">&gt;</span> <span class="token keyword">lock</span> <span class="token keyword">tables</span> mylock <span class="token keyword">write</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">&gt;</span> <span class="token keyword">SHOW</span> <span class="token keyword">OPEN</span> <span class="token keyword">TABLES</span> <span class="token keyword">where</span> In_use <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">------------+--------+--------+-------------+</span>
<span class="token operator">|</span> <span class="token keyword">Database</span>   <span class="token operator">|</span> <span class="token keyword">Table</span>  <span class="token operator">|</span> In_use <span class="token operator">|</span> Name_locked <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">------------+--------+--------+-------------+</span>
<span class="token operator">|</span> atguigudb3 <span class="token operator">|</span> mylock <span class="token operator">|</span>      <span class="token number">1</span> <span class="token operator">|</span>           <span class="token number">0</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">------------+--------+--------+-------------+</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>步骤4：释放锁</li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">#释放锁</span>
<span class="token keyword">unlock</span> <span class="token keyword">tables</span><span class="token punctuation">;</span><span class="token comment">#释放当前加锁的表</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>步骤5：加读锁</li></ul><p>为mylock表加read锁(读阻塞写)，观察阻塞的情况，流程如下:</p><p><img src="/assets/9b33a27a3ca60ea01f340074e8ea5f47.e131cd56.png" alt="img"></p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">########################SessonA中########################################</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">begin</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">&gt;</span> <span class="token keyword">lock</span> <span class="token keyword">tables</span> mylock <span class="token keyword">read</span><span class="token punctuation">;</span><span class="token comment">#为表加上读锁</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">&gt;</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> mylock<span class="token punctuation">;</span><span class="token comment">#自己可读</span>
<span class="token operator">+</span><span class="token comment">----+------+</span>
<span class="token operator">|</span> id <span class="token operator">|</span> NAME <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+------+</span>
<span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> a    <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+------+</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>


mysql<span class="token operator">&gt;</span> <span class="token keyword">update</span> mylock <span class="token keyword">set</span> name <span class="token operator">=</span> <span class="token string">&#39;a1&#39;</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">#自己不可写</span>
ERROR <span class="token number">1099</span> <span class="token punctuation">(</span>HY000<span class="token punctuation">)</span>: <span class="token keyword">Table</span> <span class="token string">&#39;mylock&#39;</span> was locked <span class="token keyword">with</span> a <span class="token keyword">READ</span> <span class="token keyword">lock</span> <span class="token operator">and</span> can<span class="token string">&#39;t be updated
mysql&gt; select * from account; # 不可操作其他表
ERROR 1100 (HY000): Table &#39;</span>account<span class="token string">&#39; was not locked with LOCK TABLES

##################################sessionB###############################
mysql&gt; select * from mylock;#其他人可以读
+----+------+
| id | NAME |
+----+------+
|  1 | a    |
+----+------+
1 row in set (0.00 sec)

mysql&gt; update mylock set name = &#39;</span>a2<span class="token string">&#39; where id = 1; #其他人不可写，需要等待
#阻塞....

########################SessionA##########################
mysql&gt; unlock tables; #释放锁
Query OK, 0 rows affected (0.00 sec)

########################SessionB#########################
mysql&gt; update mylock set name = &#39;</span>a2&#39; <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">#获取到锁，进行写操作</span>
Query OK<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token keyword">row</span> affected <span class="token punctuation">(</span><span class="token number">13.41</span> sec<span class="token punctuation">)</span>
<span class="token keyword">Rows</span> <span class="token keyword">matched</span>: <span class="token number">1</span>  Changed: <span class="token number">1</span>  <span class="token keyword">Warnings</span>: <span class="token number">0</span>

mysql<span class="token operator">&gt;</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> mylock<span class="token punctuation">;</span><span class="token comment"># 数据已经变更</span>
<span class="token operator">+</span><span class="token comment">----+------+</span>
<span class="token operator">|</span> id <span class="token operator">|</span> NAME <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+------+</span>
<span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> a2   <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+------+</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>步骤6∶加写锁</li></ul><p>为mylock表加write锁，观察阻塞的情况，流程如下:</p><p><img src="/assets/5ae371509e15a4f7363253e334a9209f.962a7ce2.png" alt="img"></p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">########################SessionA########################################</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">lock</span> <span class="token keyword">tables</span> mylock <span class="token keyword">write</span><span class="token punctuation">;</span> <span class="token comment">#为表上加写锁</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">&gt;</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> mylock<span class="token punctuation">;</span> <span class="token comment">#自己可用读</span>
<span class="token operator">+</span><span class="token comment">----+------+</span>
<span class="token operator">|</span> id <span class="token operator">|</span> NAME <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+------+</span>
<span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> a1   <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+------+</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">&gt;</span> <span class="token keyword">update</span> mylock <span class="token keyword">set</span> name <span class="token operator">=</span> <span class="token string">&#39;a2&#39;</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">#自己可以写</span>
Query OK<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token keyword">row</span> affected <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span>
<span class="token keyword">Rows</span> <span class="token keyword">matched</span>: <span class="token number">1</span>  Changed: <span class="token number">1</span>  <span class="token keyword">Warnings</span>: <span class="token number">0</span>

mysql<span class="token operator">&gt;</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> account<span class="token punctuation">;</span> <span class="token comment">#自己无法操作其他表</span>
ERROR <span class="token number">1100</span> <span class="token punctuation">(</span>HY000<span class="token punctuation">)</span>: <span class="token keyword">Table</span> <span class="token string">&#39;account&#39;</span> was <span class="token operator">not</span> locked <span class="token keyword">with</span> <span class="token keyword">LOCK</span> <span class="token keyword">TABLES</span>

<span class="token comment">############################SessionB##################################</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> mylock<span class="token punctuation">;</span> <span class="token comment">#其他人不可以读</span>
<span class="token comment">#阻塞...</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">update</span> mylock <span class="token keyword">set</span> name <span class="token operator">=</span> <span class="token string">&#39;a3&#39;</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">#其他人不可以写</span>
<span class="token comment">#阻塞...</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> account<span class="token punctuation">;</span> <span class="token comment">#可以操作其他表</span>
<span class="token operator">+</span><span class="token comment">----+--------+---------+</span>
<span class="token operator">|</span> id <span class="token operator">|</span> name   <span class="token operator">|</span> balance <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+--------+---------+</span>
<span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> abc    <span class="token operator">|</span>      <span class="token number">40</span> <span class="token operator">|</span>
<span class="token operator">|</span>  <span class="token number">2</span> <span class="token operator">|</span> 李四   <span class="token operator">|</span>       <span class="token number">0</span> <span class="token operator">|</span>
<span class="token operator">|</span>  <span class="token number">3</span> <span class="token operator">|</span> 王五   <span class="token operator">|</span>     <span class="token number">100</span> <span class="token operator">|</span>
<span class="token operator">|</span>  <span class="token number">4</span> <span class="token operator">|</span> 马六   <span class="token operator">|</span>    <span class="token number">1000</span> <span class="token operator">|</span>
<span class="token operator">|</span>  <span class="token number">5</span> <span class="token operator">|</span> 张三   <span class="token operator">|</span>    <span class="token number">6666</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+--------+---------+</span>
<span class="token number">5</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>总结：</strong></p><p>MyISAM在执行查询语句（SELECT）前，会给涉及的所有表加读锁，在执行增删改操作前，会给涉及的表加写锁。InnoDB存储引擎是不会为这个表添加表级别的<code>读锁</code>或者<code>写锁</code>的。（有行锁，谁TM用表锁啊）</p><p>MySQL的表级锁有两种模式：（以MyISAM表进行操作的演示）</p><ul><li>表共享读锁（Table Read Lock）</li><li>表独占写锁（Table Write Lock）</li></ul><table><thead><tr><th>锁类型</th><th>自己可读</th><th>自己可写</th><th>自己可操作其他表</th><th>他人可读</th><th>他人可写</th></tr></thead><tbody><tr><td>读锁</td><td>是</td><td>否</td><td>否</td><td>是</td><td>否，等</td></tr><tr><td>写锁</td><td>是</td><td>是</td><td>否</td><td>否，等</td><td>否，等</td></tr></tbody></table><h5 id="_2-意向锁-intention-lock" tabindex="-1"><a class="header-anchor" href="#_2-意向锁-intention-lock" aria-hidden="true">#</a> <strong>② 意向锁 （intention lock）</strong></h5><p>InnoDB 支持<code>多粒度锁（multiple granularity locking）</code>，它允许行级锁与表级锁共存，而 <strong>意向锁</strong> 就是其中的一种<code>表锁</code>。</p><p>1、意向锁的存在是为了<code>协调行锁和表锁</code>的关系，支持多粒度（表锁与行锁)的锁并存。</p><p>2、意向锁是一种<code>不与行级锁冲突表级锁</code>，这一点非常重要。</p><p>3、表明“某个事务正在某些行持有了锁或该事务准备去持有锁”</p><p>意向锁分为两种：</p><ul><li><p><strong>意向共享锁 （intention shared lock, IS）</strong>：事务有意向对表中的某些行加 <strong>共享锁 （S锁</strong>）</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。 
-- 会自动加，不用管
SELECT column FROM table ... LOCK IN SHARE MODE;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>意向排他锁 （intention exclusive lock, IX）</strong>：事务有意向对表中的某些行加 <strong>排他锁</strong> （X锁）</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。
-- 会自动加，不用管
SELECT column FROM table ... FOR UPDATE;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p>即：意向锁是由存储引擎<code>自己维护的</code>，用户无法手动操作意向锁，在为数据行加共享 / 排他锁之前，InooDB 会先获取该数据行<code>所在数据表的对应意向锁</code>。</p><p><strong>1.意向锁要解决的问题</strong></p><p>现在有两个事务，分别是T1和T2，其中T2试图在该表级别上应用共享或排它锁，如果没有意向锁存在，那么T2就需要去检查各个页或行是否存在锁;如果存在意向锁，那么此时就会受到由T1控制的<code>表级别意向锁的阻塞</code>。T2在锁定该表前不必检查各个页或行锁，而只需检查表上的意向锁。简单来说就是给更大一级别的空间示意里面是否已经上过锁。</p><p>在数据表的场景中，<strong>如果我们给某一行数据加上了排它锁，数据库会自动给更大一级的空间，比如数据页或数据表加上意向锁，告诉其他人这个数据页或数据表已经有人上过排它锁了</strong>(不这么做的话，想上表锁的那个程序，还要遍历有没有航所)，这样当其他人想要获取数据表排它锁的时候，只需要了解是否有人已经获取了这个数据表的意向排他锁即可。</p><ul><li>如果事务想要获得数据表中某些记录的共享锁，就需要在数据表上<code>添加意向共享锁</code>。</li><li>如果事务想要获得数据表中某些记录的排他锁，就需要在数据表上<code>添加意向排他锁</code>。</li></ul><p>这时，意向锁会告诉其他事务已经有人锁定了表中的某些记录。</p><p>举例：事务的隔离级别默认为Repeatable-Read，如下所示。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment"># 创建表teacher，插入6条数据</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>teacher<span class="token punctuation">`</span></span><span class="token punctuation">(</span>
  id <span class="token keyword">int</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4 <span class="token keyword">COLLATE</span><span class="token operator">=</span>utf8mb4_0900_ai_ci<span class="token punctuation">;</span>

<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>teacher<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span>
<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&#39;zhangsan&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">(</span><span class="token number">2</span> <span class="token punctuation">,</span> <span class="token string">&#39;lisi&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">&#39;wangwu&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">&#39;zhaoliu&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">&#39;songhongkang&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">(</span><span class="token number">6</span> <span class="token punctuation">,</span> <span class="token string">&#39;leifengyang&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment"># 查看数据</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> teacher<span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">----+--------------+</span>
<span class="token operator">|</span> id <span class="token operator">|</span> name         <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+--------------+</span>
<span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> zhangsan     <span class="token operator">|</span>
<span class="token operator">|</span>  <span class="token number">2</span> <span class="token operator">|</span> lisi         <span class="token operator">|</span>
<span class="token operator">|</span>  <span class="token number">3</span> <span class="token operator">|</span> wangwu       <span class="token operator">|</span>
<span class="token operator">|</span>  <span class="token number">4</span> <span class="token operator">|</span> zhaoliu      <span class="token operator">|</span>
<span class="token operator">|</span>  <span class="token number">5</span> <span class="token operator">|</span> songhongkang <span class="token operator">|</span>
<span class="token operator">|</span>  <span class="token number">6</span> <span class="token operator">|</span> leifengyang  <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+--------------+</span>
<span class="token number">6</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

<span class="token comment"># 假设事务A获取了某一行的排他锁，并未提交</span>
<span class="token keyword">begin</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> teacher <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">6</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span>

<span class="token comment"># 事务B想要获取teacher表的表读锁，语句如下。</span>
<span class="token keyword">begin</span> <span class="token punctuation">;</span>
<span class="token keyword">LOCK</span> <span class="token keyword">TABLES</span> teacher <span class="token keyword">READ</span><span class="token punctuation">;</span>
<span class="token comment">#阻塞...</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为共享锁与排他锁互斥，所以事务B在试图对teacher表加共享锁的时候，必须保证两个条件</p><p>（1）当前没有其他事务持有teacher表的排他锁</p><p>（2）当前没有其他事务持有teacher 表中任意一行的排他锁。</p><p>为了检测是否满足第二个条件，事务B必须在确保teacher表不存在任何排他锁的前提下，去检测表中的每一行是否存在排他锁。很明显这是一个效率很差的做法，但是有了意向锁之后，情况就不一样了。</p><p>意向锁是怎么解决这个问题的呢？首先需要知道意向锁之间的兼容互斥性，如下所示：</p><table><thead><tr><th>兼容性</th><th>意向共享锁(lS)</th><th>意向排他锁(IX)</th></tr></thead><tbody><tr><td>意向共享锁(IS)</td><td>兼容</td><td>兼容</td></tr><tr><td>意向排他锁(IX)</td><td>兼容</td><td>兼容</td></tr></tbody></table><p>即意向锁之间是互相兼容的，虽然意向锁和自家兄弟互相兼容，但是它会与普通的排他/共享锁互斥。</p><table><thead><tr><th>兼容性</th><th>意向共享锁(lS)</th><th>意向排他锁(IX)</th></tr></thead><tbody><tr><td>共享锁(S)</td><td>兼容</td><td>互斥</td></tr><tr><td>排他锁(X)</td><td>互斥</td><td>互斥</td></tr></tbody></table><blockquote><p>注意这里的排他/共享锁指的都是表锁，意向锁不会与行级的共享/排他锁互斥。 可以把意向锁看做是一种行级锁的标记</p></blockquote><p>回到刚才teacher表的例子。事务A获取了某一行的排他锁，并未提交:</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>BEGIN;
SELECT * FROM teacher WHERE id = 6 FOR UPDATE;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>此时 teacher表存在两把锁： teacher表上的意向排他锁与id为6的数据行上的排他锁。事务B想要获取teacher表的共享锁。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">BEGIN</span><span class="token punctuation">;</span>
<span class="token keyword">LOCK</span> <span class="token keyword">TABLES</span> teacher <span class="token keyword">READ</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>此时事务B检测事务A持有teacher 表的意向排他锁，就可以得知事务A必然持有该表中某些数据行的排他锁，那么事务B对teacher表的加锁请求就会被<code>排斥</code>(<code>阻塞</code>)，而<code>无需去检测</code>表中的每一行数据是否存在排他锁。</p><p><strong>2、意向锁的并发性</strong> 意向锁不会与行级的共享/排他锁互斥！正因为如此，意向锁并不会影响到多个事务对不同数据行加排他锁时的并发性。(如果互斥，那么行级锁直接就退化成表锁了，就没有什么优势了~)</p><p>我们扩展一下上面teacher表的例子来概括一下意向锁的作用（一条数据从被锁定到被释放的过程中，可能存在多种不同锁，但是这里只着重表现意向锁)</p><p><strong>①</strong> 事务A先获取了某一行的排他锁，并未提交:</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">BEGIN</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> teacher <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">6</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>②</strong> 事务A获取了teacher表上的意向排他锁，事务A获取了id为6的数据行上的排他锁。之后事务B想要获取teacher表的共享锁。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">BEGIN</span><span class="token punctuation">;</span>
<span class="token keyword">LOCK</span> <span class="token keyword">TABLES</span> teacher <span class="token keyword">READ</span> <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>③ 事务B<code>检测到</code>事务A持有teacher表的<code>意向排他锁</code>。事务B对teacher表的加锁请求被<code>阻塞</code>(排斥)。最后事务C也想获取teacher表中某一行的排他锁</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">BEGIN</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> teacher <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">5</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>事务C申请teacher表的意向排他锁。事务C检测到事务A持有teacher表的意向排他锁。<code>因为意向锁之间并不互斥</code>，所以事务C获取到了teacher表的意向排他锁。因为id为5的数据行上不存在任何排他锁，最终事务C成功获取到了该数据行上的<code>排他锁</code>。</p><p><strong>从上面的案例可以得到如下结论：</strong></p><ol><li>InnoDB 支持<code>多粒度锁</code>，特定场景下，行级锁可以与表级锁共存。</li><li>意向锁之间互不排斥，但除了 IS 与 S 兼容外，<code>意向锁会与 共享锁 / 排他锁 互斥</code>。</li><li>IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。</li><li>意向锁在保证并发性的前提下，实现了<code>行锁和表锁共存</code>且<code>满足事务隔离性</code>的要求。</li></ol><h5 id="_3-自增锁-auto-inc锁" tabindex="-1"><a class="header-anchor" href="#_3-自增锁-auto-inc锁" aria-hidden="true">#</a> <strong>③ 自增锁（AUTO-INC锁）</strong></h5><p>在使用MySQL过程中，我们可以为表的某个列添加<code>AUTO_INCREMENT</code>属性。举例：</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>CREATE TABLE `teacher` (
`id` int NOT NULL AUTO_INCREMENT,
`name` varchar( 255 ) NOT NULL,
PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于这个表的id字段声明了AUTO_INCREMENT，意味着在书写插入语句时不需要为其赋值，SQL语句修改如下所示。</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>INSERT INTO `teacher` (name) VALUES (&#39;zhangsan&#39;), (&#39;lisi&#39;);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上边的插入语句并没有为id列显式赋值，所以系统会自动为它赋上递增的值，结果如下所示。</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>mysql&gt; select * from teacher;
+----+----------+
| id | name |
+----+----------+
| 1 | zhangsan |
| 2 | lisi |
+----+----------+
2 rows in set (0.00 sec)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在我们看到的上面插入数据只是一种简单的插入模式，所有插入数据的方式总共分为三类，分别是“<code>Simple inserts</code>”，“<code>Bulk inserts</code>”和“<code>Mixed-mode inserts</code>”。</p><p><strong>1. “Simple inserts” （简单插入）</strong></p><p>可以<code>预先确定要插入的行数</code>（当语句被初始处理时）的语句。包括没有嵌套子查询的单行和多行<code>INSERT...VALUES()</code>和<code>REPLACE</code>语句。比如我们上面举的例子就属于该类插入，已经确定要插入的行数。</p><p><strong>2. “Bulk inserts” （批量插入）</strong></p><p><code>事先不知道要插入的行数</code>（和所需自动递增值的数量）的语句。比如INSERT ... SELECT，REPLACE... SELECT和LOAD DATA语句，但不包括纯INSERT。 InnoDB在每处理一行，为AUTO_INCREMENT列分配一个新值。</p><p><strong>3. “Mixed-mode inserts” （混合模式插入）</strong></p><p>这些是“Simple inserts”语句但是指定部分新行的自动递增值。例如INSERT INTO teacher (id,name) VALUES (1,&#39;a&#39;), (NULL,&#39;b&#39;), (5,&#39;c&#39;), (NULL,&#39;d&#39;);只是指定了部分id的值。另一种类型的“混合模式插入”是 <code>INSERT ... ON DUPLICATE KEY UPDATE</code>。</p><p>对于上面数据插入的案例，MySQL中采用了<code>自增锁</code>的方式来实现，<strong>AUTO-INC锁是当向使用含有AUTO_INCREMENT列的表中插入数据时需要获取的一种特殊的表级锁</strong>，在执行插入语句时就在表级别加一个AUTO-INC锁，然后为每条待插入记录的AUTO_INCREMENT修饰的列分配递增的值，在该语句执行结束后，再把AUTO-INC锁释放掉。<strong>一个事务在持有AUTO-INC锁的过程中，其他事务的插入语句都要被阻塞</strong>，可以保证<code>一个语句</code>中分配的递增值是<code>连续</code>的。也正因为此，其并发性显然并不高，<strong>当我们向一个有AUTO_INCREMENT关键字的主键插入值的时候，每条语句都要对这个表锁进行竞争</strong>，这样的并发潜力其实是很低下的，所以innodb通过<code>innodb_autoinc_lock_mode</code>的不同取值来提供不同的锁定机制，来显著提高SQL语句的可伸缩性和性能。</p><p><strong>innodb_autoinc_lock_mode有三种取值，分别对应与不同锁定模式：</strong></p><p><code>（1）innodb_autoinc_lock_mode = 0</code>(“传统”锁定模式) 在此锁定模式下，所有类型的insert语句都会获得一个特殊的表级AUTO-INC锁，用于插入具有AUTO_INCREMENT列的表。这种模式其实就如我们上面的例子，即每当执行insert的时候，都会得到一个表级锁(AUTO-INC锁)，使得语句中生成的auto_increment为顺序，且在binlog中重放的时候，可以保证master与slave中数据的auto_increment是相同的。因为是表级锁，当在同一时间多个事务中执行insert的时候，对于AUTO-INC锁的争夺会<code>限制并发能力</code>。</p><p><code>（2）innodb_autoinc_lock_mode = 1(“连续”锁定模式)</code>在 MySQL 8.0 之前，连续锁定模式是<code>默认</code>的。</p><p>在这个模式下，“bulk inserts”仍然使用AUTO-INC表级锁，并保持到语句结束。这适用于所有INSERT ...SELECT，REPLACE ... SELECT和LOAD DATA语句。同一时刻只有一个语句可以持有AUTO-INC锁。</p><p>对于“Simple inserts”（要插入的行数事先已知），则通过在<code>mutex（轻量锁）</code>的控制下获得所需数量的自动递增值来避免表级AUTO-INC锁， 它只在分配过程的持续时间内保持，而不是直到语句完成。不使用表级AUTO-INC锁，除非AUTO-INC锁由另一个事务保持。如果另一个事务保持AUTO-INC锁，则“Simple inserts”等待AUTO-INC锁，如同它是一个“bulk inserts”。</p><p><code>（ 3 ）innodb_autoinc_lock_mode = 2(“交错”锁定模式)</code>从 MySQL 8.0 开始，交错锁模式是<code>默认</code>设置。</p><p>在这种锁定模式下，所有类INSERT语句都不会使用表级AUTO-INC锁，并且可以同时执行多个语句。这是最快和最可扩展的锁定模式，但是当使用基于语句的复制或恢复方案时，<code>从二进制日志重播SQL语句时，这是不安全的。(主从复制id可能不一致)</code></p><p>在此锁定模式下，自动递增值<code>保证</code>在所有并发执行的所有类型的insert语句中是唯一且单调递增的。但是，由于多个语句可以同时生成数字（即，跨语句交叉编号）， <strong>为任何给定语句插入的行生成的值可能不是连续的。</strong></p><p>如果执行的语句是“simple inserts”，其中要插入的行数已提前知道，除了“Mixed-mode inserts&quot;之外，为单个语句生成的数字不会有间隙。然而，当执行“bulk inserts&quot;时,在由任何给定语句分配的自动递增值中可能存在间隙。</p><h5 id="_4-元数据锁-mdl锁" tabindex="-1"><a class="header-anchor" href="#_4-元数据锁-mdl锁" aria-hidden="true">#</a> <strong>④ 元数据锁（MDL锁）</strong></h5><p>MySQL5.5引入了meta data lock，简称MDL锁，属于表锁范畴。MDL 的作用是，保证读写的正确性。比如，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个<code>表结构做变更</code>，增加了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p><p>因此， <strong>当对一个表做增删改查操作的时候，加 MDL读锁；当要对表做结构变更操作的时候，加 MDL 写锁。</strong></p><p>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性，解决了DML和DDL操作之间的一致性问题。<code>不需要显式使用</code>，在访问一个表的时候会被自动加上。</p><p><strong>举例:元数据锁的使用场景模拟会话A:从表中查询数据</strong></p><ul><li>会话A：从表中查询数据</li></ul><p><img src="/assets/e5654d311e6516d580553b74e201bf68.3b4f9bff.png" alt="image-20230125165020157"></p><ul><li>会话B：修改表结构，增加新列</li></ul><p><img src="/assets/30c3da3a7c986f97161d70260ff8aff5.1bd7e0e2.png" alt="image-20230125165055077"></p><ul><li>会话C：查看当前MySQL的进程，可以得出B中的阻塞就是因为A为teacher加了MDL锁</li></ul><p><img src="/assets/68f52fcb2c93f76ad6c46590c8528389.d48981f5.png" alt="image-20230125163142559"></p><ul><li>在会话B中结束修改，进行读操作</li></ul><p><img src="/assets/7249e55851b8ccdbe18cf009807fa2fb.e7cc6358.png" alt="image-20230125163856580"></p><ul><li>B中之前的所有进行提交，重新开启事务尽心修改，同时C中也开启一个事务进行查询~</li></ul><p><img src="/assets/6253b2d3bb0d31ccd4e22bdc49dc8efb.cf81441e.png" alt="img"></p><p>可以看出会话B被阻塞，这是由于会话A拿到了teacher表的<code>元数据读锁</code>，会话B想申请teacher表的<code>元数据写锁</code>，由于读写锁互斥，会话B需要等待会话A释放元数据锁才能执行。而会话C要在表teacher上新申请MDL读锁的请求也会被<code>会话B</code> 阻塞。</p><p>前面说了，所有对表的增删改查操作都需要先申请MDL读锁，现在就都被阻塞了，等于这个表现在完全不可读写了，并发性大大降低！！！这也就是元数据锁可能带来的问题~</p><h4 id="_2-innodb中的行锁" tabindex="-1"><a class="header-anchor" href="#_2-innodb中的行锁" aria-hidden="true">#</a> 2. InnoDB中的行锁</h4><p>行锁(Row Lock)也称为记录锁，顾名思义，就是锁住某一行（某条记录row)。需要的注意的是，MySQL服务器层并没有实现行锁机制，<strong>行级锁只在存储引擎层实现。</strong></p><p>优点: 锁定力度小，<code>发生锁冲突概率低</code>，可以实现的<code>并发度高</code>。</p><p>缺点: 对于<code>锁的开销比大</code>，加锁会比较慢，容易出现<code>死锁</code>情况。</p><p>InnoDB与MylSAM的最大不同有两点：一是支持事务(TRANSACTION)；二是采用了行级锁。</p><p>演示环境搭建</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment"># 创建表</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> student <span class="token punctuation">(</span>
  id <span class="token keyword">INT</span><span class="token punctuation">,</span>
  name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  class <span class="token keyword">varchar</span> <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">,</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token keyword">Engine</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span>

<span class="token comment"># 插入几条记录</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> student <span class="token keyword">VALUES</span>
<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">&#39;张三&#39;</span> <span class="token punctuation">,</span><span class="token string">&#39;一班&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">&#39;李四&#39;</span> <span class="token punctuation">,</span><span class="token string">&#39;一班&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">(</span> <span class="token number">8</span><span class="token punctuation">,</span><span class="token string">&#39;王五&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;二班&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">(</span> <span class="token number">15</span><span class="token punctuation">,</span><span class="token string">&#39;赵六&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;二班&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token string">&#39;钱七&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;三班&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment"># 查看</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> student<span class="token punctuation">;</span>
<span class="token comment">/*
+----+--------+--------+
| id | name   | class  |
+----+--------+--------+
|  1 | 张三   | 一班   |
|  3 | 李四   | 一班   |
|  8 | 王五   | 二班   |
| 15 | 赵六   | 二班   |
| 20 | 钱七   | 三班   |
+----+--------+--------+
*/</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>student表中的聚簇索引的简图如下所示</p><p><img src="/assets/97a04f61dc976fc668acf811408c7497.4b503a51.png" alt="image-20230125202318828"></p><p>这里把B+树的索引结构做了一个超级简化，只把索引中的记录给拿了出来，下面看看都有哪些常用的行锁类型。</p><p><strong>① 记录锁（Record Locks）</strong></p><p>记录锁也就是仅仅把一条记录锁上，官方的类型名称为：<code>LOCK_REC_NOT_GAP</code>。比如我们把id值为 8 的 那条记录加一个记录锁的示意图如图所示。仅仅是锁住了id值为 8 的记录，对周围的数据没有影响。</p><p><img src="/assets/17d91203e351aebc3edec95ba3782257.a98fea1a.png" alt="image-20230125202950342"></p><p>举例如下：</p><p><img src="/assets/e4be4597b499141bd215d9f51f3e37fc.32fa7590.png" alt="image-20230125203029242"></p><p>代码演示：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">###############################SessionA###################################</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">begin</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">&gt;</span> <span class="token keyword">update</span> student <span class="token keyword">set</span> name <span class="token operator">=</span> <span class="token string">&#39;张三1&#39;</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">#为id=1的记录加X型的行锁</span>
Query OK<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token keyword">row</span> affected <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span>
<span class="token keyword">Rows</span> <span class="token keyword">matched</span>: <span class="token number">1</span>  Changed: <span class="token number">1</span>  <span class="token keyword">Warnings</span>: <span class="token number">0</span>

<span class="token comment">###############################SessionB###################################</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">begin</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">&gt;</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">2</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share</span> <span class="token keyword">mode</span><span class="token punctuation">;</span>
Empty <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">&gt;</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">3</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share</span> <span class="token keyword">mode</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">----+--------+--------+</span>
<span class="token operator">|</span> id <span class="token operator">|</span> name   <span class="token operator">|</span> class  <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+--------+--------+</span>
<span class="token operator">|</span>  <span class="token number">3</span> <span class="token operator">|</span> 李四   <span class="token operator">|</span> 一班   <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+--------+--------+</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">&gt;</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share</span> <span class="token keyword">mode</span><span class="token punctuation">;</span> 
<span class="token comment">#阻塞...因为sessonA中的事务对该记录了X锁</span>
ERROR <span class="token number">1205</span> <span class="token punctuation">(</span>HY000<span class="token punctuation">)</span>: <span class="token keyword">Lock</span> wait timeout exceeded<span class="token punctuation">;</span> <span class="token comment">#执行超时</span>

mysql<span class="token operator">&gt;</span> <span class="token keyword">update</span> student <span class="token keyword">set</span> name <span class="token operator">=</span> <span class="token string">&#39;李四1&#39;</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">#为id=3的记录加X型的锁</span>
Query OK<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token keyword">row</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>
<span class="token keyword">Rows</span> <span class="token keyword">matched</span>: <span class="token number">1</span>  Changed: <span class="token number">1</span>  <span class="token keyword">Warnings</span>: <span class="token number">0</span>

mysql<span class="token operator">&gt;</span> <span class="token keyword">update</span> student <span class="token keyword">set</span> name <span class="token operator">=</span> <span class="token string">&#39;张三2&#39;</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token comment">#阻塞...</span>
ERROR <span class="token number">1205</span> <span class="token punctuation">(</span>HY000<span class="token punctuation">)</span>: <span class="token keyword">Lock</span> wait timeout exceeded<span class="token punctuation">;</span> <span class="token comment">#执行超时</span>


<span class="token comment">###############################SessionA###################################</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">commit</span><span class="token punctuation">;</span> <span class="token comment">#提交</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span>
<span class="token comment">###############################SessionB###################################</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">update</span> student <span class="token keyword">set</span> name <span class="token operator">=</span> <span class="token string">&#39;张三2&#39;</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">#再次尝试获取X锁，执行成功</span>
Query OK<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token keyword">row</span> affected <span class="token punctuation">(</span><span class="token number">5.74</span> sec<span class="token punctuation">)</span>
<span class="token keyword">Rows</span> <span class="token keyword">matched</span>: <span class="token number">1</span>  Changed: <span class="token number">1</span>  <span class="token keyword">Warnings</span>: <span class="token number">0</span>

mysql<span class="token operator">&gt;</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student<span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">----+---------+--------+</span>
<span class="token operator">|</span> id <span class="token operator">|</span> name    <span class="token operator">|</span> class  <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+---------+--------+</span>
<span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> 张三<span class="token number">2</span>   <span class="token operator">|</span> 一班   <span class="token operator">|</span>
<span class="token operator">|</span>  <span class="token number">3</span> <span class="token operator">|</span> 李四<span class="token number">1</span>   <span class="token operator">|</span> 一班   <span class="token operator">|</span>
<span class="token operator">|</span>  <span class="token number">8</span> <span class="token operator">|</span> 王五    <span class="token operator">|</span> 二班   <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">15</span> <span class="token operator">|</span> 赵六    <span class="token operator">|</span> 二班   <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">20</span> <span class="token operator">|</span> 钱七    <span class="token operator">|</span> 三班   <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+---------+--------+</span>
<span class="token number">5</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>记录锁是有S锁和X锁之分的，称之为<code>S型记录锁</code>和<code>X型记录锁</code>。</p><ul><li>当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可以继续获取X型记录锁；</li><li>当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不可以继续获取X型记录锁。</li></ul><p><strong>② 间隙锁（Gap Locks）</strong></p><p>MySQL在<code>REPEATABLE READ</code>隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用<code>MVCC</code>方案解决，也可以采用加锁方案解决。但是在使用<code>加锁</code>方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些<code>幻影记录</code>加上<code>记录锁</code>。InnoDB提出了一种称之为<code>Gap Locks</code>的锁，官方的类型名称为：<code>LOCK_GAP</code>，我们可以简称为<code>gap锁</code>。比如，把id值为 8 的那条记录加一个gap锁的示意图如下。</p><p><img src="/assets/8419d198c1431f0c597891bb6052de7d.95e8b36b.png" alt="img"></p><p>图中id值为 8 的记录加了gap锁，意味着<code>不允许别的事务在id值为 8 的记录前边的间隙插入新记录</code>，其实就是id列的值( 3 , 8 )这个区间的新记录是不允许立即插入的。比如，有另外一个事务再想插入一条id值为 4 的新记录，它定位到该条新记录的下一条记录的id值为 8 ，而这条记录上又有一个gap锁，所以就会阻塞插入操作，直到拥有这个gap锁的事务提交了之后，id列的值在区间( 3 , 8 )中的新记录才可以被插入。</p><p><strong>gap锁的提出仅仅是为了防止插入幻影记录而提出的</strong> 。虽然有共享<code>gap锁</code>和<code>独占gap锁</code>这样的说法，但是它们起到的作用是相同的。而且如果对一条记录加了gap锁（不论是共享gap锁还是独占gap锁)，并不会限制其他事务对这条记录加记录锁或者继续加gap锁。</p><p>举例：</p><table><thead><tr><th>Session1</th><th>Session2</th></tr></thead><tbody><tr><td>select * from student where id = 5 lock in share mode;</td><td></td></tr><tr><td></td><td>select * from student where id = 5 for update;</td></tr></tbody></table><p>这里session 2并不会被堵住。因为表里并没有id=5这个记录，因此 session 1加的是间隙锁（3,8)。而session 2也是在这个间隙加的间隙锁。它们有共同的目标，即:保护这个间隙，不允许插入值。但，它们之间是不冲突的。</p><p>**注意，**给一条记录加了<code>gap锁</code>只是不允许其他事务往这条记录前边的间隙<code>插入新记录</code>，那对于最后一条记录之后的间隙，也就是student 表中id值为<code>20</code>的记录之后的间隙该咋办呢？也就是说给哪条记录加<code>gap锁</code>才能阻止其他事务插入<code>id值</code>在(20，<code>正无穷</code>)这个区间的新记录呢？这时候我们在讲数据页时介绍的两条伪记录派上用场了：</p><ul><li><code>Infimum</code>记录，表示该页面中最小的记录。</li><li><code>Supremum</code>记录，表示该页面中最大的记录。</li></ul><p>为了实现阻止其他事务插入id值在(20, 正无穷)这个区间的新记录，可以给索引中的最后一条记录，也就是id值为20的那条记录所在页面的<code>Supremum</code>记录加上一个gap锁，如图所示</p><p><img src="/assets/234f220e1d1aadedd43f9aac7334a777.9982e38a.png" alt="image-20230125210502347"></p><p><strong>代码演示：</strong></p><ul><li>关于X和S锁互斥的知识回顾</li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">###############################SessionA###################################</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">begin</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">&gt;</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">8</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share</span> <span class="token keyword">mode</span><span class="token punctuation">;</span> <span class="token comment">#为id=8的记录加S锁</span>
<span class="token operator">+</span><span class="token comment">----+--------+--------+</span>
<span class="token operator">|</span> id <span class="token operator">|</span> name   <span class="token operator">|</span> class  <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+--------+--------+</span>
<span class="token operator">|</span>  <span class="token number">8</span> <span class="token operator">|</span> 王五   <span class="token operator">|</span> 二班   <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+--------+--------+</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

<span class="token comment">###############################SessionB####################################</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">8</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span> <span class="token comment"># A已经为id=8的加了S锁，B就不能加X锁了</span>
<span class="token operator">^</span>C<span class="token operator">^</span>C <span class="token comment">-- query aborted</span>
ERROR <span class="token number">1317</span> <span class="token punctuation">(</span><span class="token number">70100</span><span class="token punctuation">)</span>: Query execution was interrupted

<span class="token comment">#################SessionA&amp;SessionB########################################</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">commit</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>间隙锁</li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">#############################SessionA#####################################</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">begin</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

<span class="token comment"># id=5的记录不存在，所以无法加上记录锁~ 对于不存在的记录，加的是间隙锁。（3-8）</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">5</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share</span> <span class="token keyword">mode</span><span class="token punctuation">;</span> 
Empty <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

<span class="token comment">############################SessionB####################################</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">begin</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

<span class="token comment"># 依旧加的是间隙锁。可以看出共享gap锁和独占gap锁作用相同，而且可以重复加~</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">5</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>
Empty <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

<span class="token comment">##########################SessionC######################################</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">insert</span> <span class="token keyword">into</span> student<span class="token punctuation">(</span>id<span class="token punctuation">,</span>name<span class="token punctuation">,</span>class<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token string">&#39;tom&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;三班&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">#在间隙锁范围内，无法插入</span>
<span class="token comment">#阻塞...</span>
ERROR <span class="token number">1205</span> <span class="token punctuation">(</span>HY000<span class="token punctuation">)</span>: <span class="token keyword">Lock</span> wait timeout exceeded<span class="token punctuation">;</span> try restarting <span class="token keyword">transaction</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>可以这样实现加 id &gt; 20的间隙锁：</li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>mysql<span class="token operator">&gt;</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">25</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share</span> <span class="token keyword">mode</span><span class="token punctuation">;</span>
Empty <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">&gt;</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student <span class="token keyword">where</span> id <span class="token operator">&gt;</span> <span class="token number">20</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>
Empty <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>注意：如果记录存在，则使用<code>for update</code> 或 <code>lock in share mode</code> 加的就是记录锁，如果记录不存在加的就是间隙锁~</p></blockquote><p>间隙锁的引入，可能会导致同样的语句锁住更大的范围，这其实是影响了并发度的。下面的例子会产生死锁。</p><table><thead><tr><th>Session1</th><th>Session2</th></tr></thead><tbody><tr><td>begin; select *from student where id = 5 for update;</td><td>begin;select * from student where id = 5 for update;</td></tr><tr><td></td><td>INSERT INTO student VALUES(5,&#39;宋红康,‘二班’);阻塞</td></tr><tr><td>INSERT INTO student VALUES(5,‘宋红康’,‘二班’);(ERROR 1213(40001):Deadlock found when trying to get lock; try restarting transaction)</td><td></td></tr></tbody></table><p>① session 1执行select …for update语句，由于id = 5这一行并不存在，因此会<code>加上间隙锁(3，8)</code>;</p><p>② session2执行select … for update语句，同样会<code>加上间隙锁（3，8)</code>，间隙锁之间不会冲突，因此这个语句可以执行成功;</p><p>③ session 2试图插入一行(5, ‘宋红康’, ‘二班’)，被session 1的间隙锁挡住了，只好<code>进入等待</code>；</p><p>④ session 1试图插入一行(5. 宋红康’二班)，被session2的间隙锁挡住了。至此，两个session陷入<code>死锁</code>。</p><p><strong>代码演示：</strong></p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">#############################SessionA####################################</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">begin</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">&gt;</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">5</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share</span> <span class="token keyword">mode</span><span class="token punctuation">;</span> <span class="token comment">#为id=5加间隙锁</span>
Empty <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

<span class="token comment">#############################SessionB####################################</span>

mysql<span class="token operator">&gt;</span> <span class="token keyword">begin</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">&gt;</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">5</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span> <span class="token comment">#为id=5加间隙锁</span>
Empty <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">&gt;</span> <span class="token keyword">insert</span> <span class="token keyword">into</span> student<span class="token punctuation">(</span>id<span class="token punctuation">,</span>name<span class="token punctuation">,</span>class<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token string">&#39;Tom&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;一班&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">#id=7在间隙区间</span>
<span class="token comment">#阻塞...</span>

<span class="token comment">###########################SessionA######################################</span>
<span class="token comment">#出现了死锁，也可能在B中出现</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">insert</span> <span class="token keyword">into</span> student<span class="token punctuation">(</span>id<span class="token punctuation">,</span>name<span class="token punctuation">,</span>class<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token string">&#39;Jane&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;一班&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
ERROR <span class="token number">1213</span> <span class="token punctuation">(</span><span class="token number">40001</span><span class="token punctuation">)</span>: Deadlock found <span class="token keyword">when</span> trying <span class="token keyword">to</span> get <span class="token keyword">lock</span><span class="token punctuation">;</span> try restarting <span class="token keyword">transaction</span>

<span class="token comment">##########################SessionB##################################</span>
<span class="token comment">#出现死锁后，按照策略，让A回滚，从而B中的Insert执行成功~</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> student<span class="token punctuation">(</span>id<span class="token punctuation">,</span>name<span class="token punctuation">,</span>class<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token string">&#39;Tom&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;一班&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
Query OK<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token keyword">row</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>分析：为什么会出现 死锁呢？</p><p>当SessionA中执行Insert，就会造成：B中Insert在等A中的间隙锁的释放~ A中的Insert在等B中间隙锁的释放~ （因为只有释放后，这俩各自的Insert才会继续执行）。从而A和B相互等待，就产生了<code>死锁</code></p><p>那为啥发生死锁后，A执行失败，B又成功执行了呢？(参见 3.6其它锁之:死锁)</p><p>这涉及MySQL的处理死锁机制。当MySQL发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务（将持有最少行级排他锁的事务进行回滚），让其他事务得以继续执行!</p><p><strong>③ 临键锁（Next-Key Locks）</strong></p><p>有时候我们既想<code>锁住某条记录</code>，又想<code>阻止</code>其他事务在该记录前边的<code>间隙插入新记录</code>，所以InnoDB就提出了一种称之为<code>Next-Key Locks的锁</code>，官方的类型名称为：<code>LOCK_ORDINARY</code>，我们也可以简称为next-key锁。<code>Next-Key Locks</code>是在存储引擎innodb、事务级别在<code>可重复读</code>的情况下使用的数据库锁，innodb默认的锁就是Next-Key locks。</p><p>比如，把id值为8的那条记录加一个next-key锁的示意图如下:</p><p><img src="/assets/5e059cb4dac97ea6686b2480a9379b9c.7cdaac9d.png" alt="img"></p><p>next-key<code>锁的本质就是一个</code>记录锁<code>和一个</code>gap锁<code>的合体，它既能保护该条记录，又能阻止别的事务将新记录插入被保护记录前边的</code>间隙</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student <span class="token keyword">where</span> id <span class="token operator">&lt;=</span><span class="token number">8</span> <span class="token operator">and</span> id <span class="token operator">&gt;</span> <span class="token number">3</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>代码演示</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">#############################SessionA####################################</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">begin</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

<span class="token comment"># 为(8，,15]加邻键锁（8-15是间隙 + 15记录锁）</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student <span class="token keyword">where</span> id <span class="token operator">&lt;=</span> <span class="token number">15</span> <span class="token operator">and</span> id <span class="token operator">&gt;</span> <span class="token number">8</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span> 
<span class="token operator">+</span><span class="token comment">----+--------+--------+</span>
<span class="token operator">|</span> id <span class="token operator">|</span> name   <span class="token operator">|</span> class  <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+--------+--------+</span>
<span class="token operator">|</span> <span class="token number">15</span> <span class="token operator">|</span> 赵六   <span class="token operator">|</span> 二班   <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+--------+--------+</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

<span class="token comment">#############################SessionB####################################</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">begin</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">&gt;</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">15</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share</span> <span class="token keyword">mode</span><span class="token punctuation">;</span> <span class="token comment">#无法获取S锁</span>
<span class="token operator">^</span>C<span class="token operator">^</span>C <span class="token comment">-- query aborted</span>
ERROR <span class="token number">1317</span> <span class="token punctuation">(</span><span class="token number">70100</span><span class="token punctuation">)</span>: Query execution was interrupted
mysql<span class="token operator">&gt;</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">15</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span> <span class="token comment">#无法获取X锁</span>
<span class="token operator">^</span>C<span class="token operator">^</span>C <span class="token comment">-- query aborted</span>
ERROR <span class="token number">1317</span> <span class="token punctuation">(</span><span class="token number">70100</span><span class="token punctuation">)</span>: Query execution was interrupted
mysql<span class="token operator">&gt;</span> <span class="token keyword">insert</span> <span class="token keyword">into</span> student<span class="token punctuation">(</span>id<span class="token punctuation">,</span>name<span class="token punctuation">,</span>class<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token string">&#39;Tim&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;一班&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">#无法在间隙内插入数据</span>
<span class="token operator">^</span>C<span class="token operator">^</span>C <span class="token comment">-- query aborted</span>
ERROR <span class="token number">1317</span> <span class="token punctuation">(</span><span class="token number">70100</span><span class="token punctuation">)</span>: Query execution was interrupted
    
<span class="token comment">###############################SessionA&amp;SessionB#######################</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">commit</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>④ 插入意向锁（Insert Intention Locks）</strong></p><p>我们说一个事务在<code>插入</code>一条记录时需要判断一下插入位置是不是被别的事务加了<code>gap锁</code>（<code>next-key锁</code>也包含<code>gap锁</code>），如果有的话，插入操作需要等待，直到拥有<code>gap锁</code>的那个事务提交。但是 <strong>InnoDB规定事务在等待的时候也需要在内存中生成一个锁结构</strong> ，表明有事务想在某个<code>间隙</code>中<code>插入</code>新记录，但是现在在等待。InnoDB就把这种类型的锁命名为Insert Intention Locks，官方的类型名称为：<code>LOCK_INSERT_INTENTION</code>，我们称为插入意向锁。<code>插入意向锁</code>是一种<code>Gap锁</code>，不是意向锁，在insert操作时产生。</p><blockquote><p>插入意向锁是在插入一条记录行前，由 <code>INSERT 操作产生的一种间隙锁。</code></p><p>事实上 <strong>插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁。</strong></p></blockquote><p>插入意向锁是在插入一条记录行前，由INSERT 操作产生的一种间隙锁。该锁用以表示<code>插入意向</code>，当多个事务在同一区间(gap）插入<code>位置不同</code>的多条数据时，事务之间<code>不需要互相等待</code>。假设存在两条值分别为8和15的记录，两个不同的事务分别试图插入值为11和12的两条记录，每个事务在获取插入行上独占的(排他）锁前，都会获取(8，15）之间的间隙锁，但是因为数据行之间并<code>不冲突</code>，所以两个事务之间并不会产生冲突（<code>阻塞等待</code>)。总结来说，插入意向锁的特性可以分成两部分：</p><p>(1）插入意向锁是一种特殊的间隙锁―—间隙锁可以锁定开区间内的部分记录。</p><p>(2）插入意向锁之间互不排斥，所以即使多个事务在同一区间插入多条记录，只要记录本身(主键、唯一索引)<code>不冲突</code>，那么事务之间就不会出现冲突等待</p><p>注意，虽然插入意向锁中含有意向锁三个字，但是它并不属于意向锁而属于间隙锁，因为意向锁是表锁而插入意向锁是行锁</p><p>比如，把id值为8的那条记录加一个插入意向锁的示意图如下:</p><p><img src="/assets/a0127bf3c664544c051fdf8a7cee806f.75fd5590.png" alt="image-20230126151811673"></p><p>比如，现在T1为id值为8的记录加了一个gap锁，然后T2和T3分别想向student表中插入id值分别为4、5的两条记录，所以现在为id值为8的记录加的锁的示意图就如下所示:</p><p><img src="/assets/9c609918612246cd921aeda854a9047a.84167a1c.png" alt="image-20230126151840355"></p><p>从图中可以看到，由于<code>T1持有gap锁</code>，所以<code>T2和T3</code>需要<code>生成一个插入意向锁</code>的锁结构并且处于<code>等待</code>状态。当T1提交后会把它获取到的锁都释放掉，这样T2和T3就能<code>获取</code>到对应的插入意向锁了(本质上就是把插入意向锁对应锁结构的is_waiting属性改为false)，T2和T3之间也并不会相互阻塞，它们可以<code>同时</code>获取到id值为8的插入意向锁，然后执行插入操作。事实上插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁。</p><p><strong>演示-插入意向锁</strong></p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">###############################SessionA####################################</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">begin</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">&gt;</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">12</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span> <span class="token comment">#加间隙锁</span>
Empty <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

<span class="token comment">###############################SessionB####################################</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">begin</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">&gt;</span> <span class="token keyword">insert</span> <span class="token keyword">into</span> student<span class="token punctuation">(</span>id<span class="token punctuation">,</span>name<span class="token punctuation">,</span>class<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token string">&#39;Tim&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;一班&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment">#阻塞..同时会加插入意向锁</span>

<span class="token comment">##############################SessionC###################################</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">begin</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">&gt;</span>  <span class="token keyword">insert</span> <span class="token keyword">into</span> student<span class="token punctuation">(</span>id<span class="token punctuation">,</span>name<span class="token punctuation">,</span>class<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token string">&#39;Tim&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;一班&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">#阻塞..同时会加插入意向锁。 可以看出插入意向锁是相互兼容的，毕竟id都不同嘛</span>

<span class="token comment">##############################SessionA#################################</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">commit</span><span class="token punctuation">;</span> <span class="token comment">#提交</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

<span class="token comment">#############################SessionB###############################</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">insert</span> <span class="token keyword">into</span> student<span class="token punctuation">(</span>id<span class="token punctuation">,</span>name<span class="token punctuation">,</span>class<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token string">&#39;Tim&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;一班&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">#插入成功</span>
Query OK<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token keyword">row</span> affected <span class="token punctuation">(</span><span class="token number">45.43</span> sec<span class="token punctuation">)</span>
<span class="token comment">##############################SessionC#################################</span>
mysql<span class="token operator">&gt;</span>  <span class="token keyword">insert</span> <span class="token keyword">into</span> student<span class="token punctuation">(</span>id<span class="token punctuation">,</span>name<span class="token punctuation">,</span>class<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token string">&#39;Tim&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;一班&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">#插入成功</span>
Query OK<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token keyword">row</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_3-页锁" tabindex="-1"><a class="header-anchor" href="#_3-页锁" aria-hidden="true">#</a> 3. 页锁</h4><p>页锁就是在<code>页的粒度</code>上进行锁定，锁定的数据资源比行锁要多，因为一个页中可以有多个行记录。当我们使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。 <strong>页锁的开销介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般。</strong></p><p>每个层级的锁数量是有限制的，因为锁会占用内存空间，<code>锁空间的大小是有限的</code>。当某个层级的锁数量超过了这个层级的阈值时，就会进行<code>锁升级</code>。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如InnoDB 中行锁升级为表锁，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。</p><p>死锁演示：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>事务A目前锁定了页A，想要锁定页B才可以执行完。
事务B目前锁定了页B，想要锁定页A才可以执行完。
<span class="token comment">### 死锁</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-3-从对待锁的态度划分-乐观锁、悲观锁" tabindex="-1"><a class="header-anchor" href="#_3-3-从对待锁的态度划分-乐观锁、悲观锁" aria-hidden="true">#</a> 3. 3 从对待锁的态度划分:乐观锁、悲观锁</h3><p>从对待锁的态度来看锁的话，可以将锁分成乐观锁和悲观锁，从名字中也可以看出这两种锁是两种看待<code>数据并发的思维方式</code>。需要注意的是，乐观锁和悲观锁并不是锁，而是锁的<code>设计思想</code>。</p><h4 id="_1-悲观锁-pessimistic-locking" tabindex="-1"><a class="header-anchor" href="#_1-悲观锁-pessimistic-locking" aria-hidden="true">#</a> 1. 悲观锁（Pessimistic Locking）</h4><p>悲观锁是一种思想，顾名思义，就是很悲观，对数据被其他事务的修改持保守态度，会通过数据库自身的锁机制来实现，从而保证数据操作的排它性。</p><p>悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会<code>阻塞</code>直到它拿到锁（ <!---->）。比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁，当其他线程想要访问数据时，都需要阻塞挂起。Java中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p><p><strong>秒杀案例1：</strong></p><p>商品秒杀过程中，库存数量的减少，避免出现<code>超卖</code>的情况。比如，商品表中有一个字段为quantity表示当前该商品的库存量。假设商品为华为mate40，id为1001，quantity=100个。如果不使用锁的情况下，操作方法如下所示:</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">#第1步:查出商品库存</span>
<span class="token keyword">select</span> quantity <span class="token keyword">from</span> items <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1001</span> <span class="token punctuation">;</span>
<span class="token comment">#第2步:如果库存大于0，则根据商品信息生产订单</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> orders <span class="token punctuation">(</span>item_id）<span class="token keyword">values</span> <span class="token punctuation">(</span> <span class="token number">1001</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token comment">#第3步:修改商品的库存，num表示购买数量</span>
<span class="token keyword">update</span> items <span class="token keyword">set</span> quantity <span class="token operator">=</span> quantity<span class="token operator">-</span>num <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1001</span> <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样写的话，在并发量小的公司没有大的问题，但是如果在 <code>高并发环境</code> 下可能出现以下问题</p><table><thead><tr><th></th><th>线程A</th><th>线程B</th></tr></thead><tbody><tr><td>1</td><td>step1(查询还有100部手机)</td><td>step1(查询还有100部手机)</td></tr><tr><td>2</td><td></td><td>step2(生成订单)</td></tr><tr><td>3</td><td>step2(生成订单)</td><td></td></tr><tr><td>4</td><td></td><td>step3(减库存1)</td></tr><tr><td>5</td><td>step3(减库存2)</td><td></td></tr></tbody></table><p>其中线程B此时已经下单并且减完库存，这个时候线程A依然去执行step3，就可能会造成<code>超卖</code>。</p><p>我们使用悲观锁可以解决这个问题，商品信息从查询出来到修改，中间有一个生成订单的过程，使用悲观锁的原理就是，在查询items信息后就把当前的数据锁定，直到修改完毕后再解锁。那么整个过程中，因为数据被锁定了，就不会出现有第三者来对其进行修改了。而这样做的前提是需要将要执行的SQL语句放在同一个事务中，否则达不到锁定数据行的目的。</p><p>修改如下:</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">#第1步:查出商品库存</span>
<span class="token keyword">select</span> quantity <span class="token keyword">from</span> items <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1001</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>
<span class="token comment">#第2步:如果库存大于0，则根据商品信息生产订单</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> orders <span class="token punctuation">(</span>item_id<span class="token punctuation">)</span><span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1001</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">#第3步:修改商品的库存，num表示购买数量</span>
<span class="token keyword">update</span> items <span class="token keyword">set</span> quantity <span class="token operator">=</span> quantity<span class="token operator">-</span>num <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1001</span> <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>select … for update</code> 是MySQL中悲观锁。 此时在items表中，id为1001的那条数据就被锁定了，其他的要执行<code>select quantity from items where id = 1001 for update;</code>语句的事务必须等本次事务提交之后才能执行。这样可以保证当前的数据不会被其它事务修改。</p><blockquote><p>注意，当执行select quantity from items where id = 1001 for update;语句之后，如果在其他事务中执行select quantity from items where id = 1001;语句，并不会受第一个事务的影响，仍然可以正常查询出数据。</p></blockquote><p>另外，select … for update语句执行过程中所有扫描的行都会被锁上，因此在MySQL中用悲观锁必须确定使用了索引，而不是全表扫描，否则将会把整个表锁住（表锁）。</p><blockquote><p>InnoDB 行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据 InnoDB 才使用行级锁，否则 InnoDB 将使用表锁~</p></blockquote><p>悲观锁不适用的场景较多，它存在一些不足，因为悲观锁大多数情况下依靠数据库的锁机制来实现，以保证程序的并发访问性，同时这样对数据库性能开销影响也很大，特别是 <code>长事务</code> 而言，这样的 <code>开销往往无法承受</code>，这时就需要乐观锁。</p><h4 id="_2-乐观锁-optimistic-locking" tabindex="-1"><a class="header-anchor" href="#_2-乐观锁-optimistic-locking" aria-hidden="true">#</a> 2. 乐观锁（Optimistic Locking）</h4><p>乐观锁认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，也就是 <strong>不采用数据库自身的锁机制，而是通过程序来实现</strong> 。在程序上，我们可以采用<code>版本号机制</code>或者<code>CAS机制</code>实现。 <strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong> 。在Java中java.util.concurrent.atomic包下的原子变量类就是使用了乐观锁的一种实现方式：CAS实现的。</p><p><strong>1.乐观锁的版本号机制</strong></p><p>在表中设计一个<code>版本字段 version</code>，第一次读的时候，会获取 version 字段的取值。然后对数据进行更新或删除操作时，会执行<code>UPDATE ... SET version=version+1 WHERE version=version</code>。此时如果已经有事务对这条数据进行了更改，修改就不会成功。</p><p><strong>2. 乐观锁的时间戳机制</strong></p><p>时间戳和版本号机制一样，也是在更新提交的时候，将当前数据的时间戳和更新之前取得的时间戳进行比较，如果两者一致则更新成功，否则就是版本冲突。</p><p>你能看到乐观锁就是程序员自己控制数据并发操作的权限，基本是通过给数据行增加一个戳（版本号或者时间戳），从而证明当前拿到的数据是否最新。</p><p>秒杀案例2</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">#第1步:查出商品库存</span>
<span class="token keyword">select</span> quantity <span class="token keyword">from</span> items <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1001</span><span class="token punctuation">;</span>

<span class="token comment">#第2步:如果库存大于0，则根据商品信息生产订单</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> orders <span class="token punctuation">(</span>item_id）<span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token number">1001</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">#第3步:修改商品的库存,num表示购买数量</span>
<span class="token keyword">update</span> items <span class="token keyword">set</span> quantity <span class="token operator">=</span> quantity<span class="token operator">-</span>num <span class="token punctuation">,</span> version <span class="token operator">=</span> version<span class="token operator">+</span><span class="token number">1</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1001</span> <span class="token operator">and</span> version <span class="token operator">=</span> <span class="token comment">#{version} ;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，如果数据表是 <code>读写分离</code> (主写从读)的表，当matser表中写入的数据没有及时同步到slave表中时，会造成更新一直失败的问题。此时需要<code>强制读取master表</code>中的数据（即将select语句放到事务中即可，这时候查询的就是master主库了)</p><p>如果对同一条数据进行 <code>频繁的修改</code> 的话，那么就会出现这么一种场景，每次修改都只有一个事务能更新成功，在业务感知上面就有大量的失败操作。我们把代码修改如下:</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">#第1步:查出商品库存</span>
<span class="token keyword">select</span> quantity <span class="token keyword">from</span> items <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1001</span><span class="token punctuation">;</span>

<span class="token comment">#第2步:如果库存大于0，则根据商品信息生产订单</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> orders <span class="token punctuation">(</span>item_id<span class="token punctuation">)</span><span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1001</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">#第3步:修改商品的库存，num表示购买数量</span>
<span class="token keyword">update</span> items <span class="token keyword">set</span> quantity <span class="token operator">=</span> quantity<span class="token operator">-</span>num <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1001</span> <span class="token operator">and</span> quantity<span class="token operator">-</span>num <span class="token operator">&gt;</span> <span class="token number">6</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样就会使每次修改都能成功，而且不会出现超卖的现象。</p><h4 id="_3-两种锁的适用场景" tabindex="-1"><a class="header-anchor" href="#_3-两种锁的适用场景" aria-hidden="true">#</a> 3. 两种锁的适用场景</h4><p>从这两种锁的设计思想中，我们总结一下乐观锁和悲观锁的适用场景：</p><ol><li><code>乐观锁</code>适合<code>读操作多</code>的场景，相对来说写的操作比较少。它的优点在于程序实现，不存在死锁</li></ol><p>问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。</p><ol start="2"><li><code>悲观锁</code>适合<code>写操作多</code>的场景，因为写的操作具有<code>排它性</code>。采用悲观锁的方式，可以在数据库层</li></ol><p>面阻止其他事务对该数据的操作权限，防止<code>读 - 写</code>和<code>写 - 写</code>的冲突。</p><p>把乐观锁和悲观锁总结如下图所示</p><p><img src="/assets/d1114e6ee32873d931a4ee4c6f3819f2.56d377e4.png" alt="image-20230127145003149"></p><h3 id="_3-4-按加锁的方式划分-显式锁、隐式锁" tabindex="-1"><a class="header-anchor" href="#_3-4-按加锁的方式划分-显式锁、隐式锁" aria-hidden="true">#</a> 3. 4 按加锁的方式划分：显式锁、隐式锁</h3><h4 id="_1-隐式锁" tabindex="-1"><a class="header-anchor" href="#_1-隐式锁" aria-hidden="true">#</a> 1. 隐式锁</h4><blockquote><p>回顾</p><p>一个事务在执行<code>INSERT</code>操作时，如果即将插入的<code>间隙</code>已经被其他事务加了<code>gap锁</code>，那么本次<code>INSERT</code>操作会阻塞，并且当前事务会在该间隙上加一个<code>插入意向锁</code>。【被动加锁】</p><p>否则，一般情况下，新插入一条记录的操作并不加锁（后面会推翻这个结论，严格来说是加锁的，隐式锁）【主动加锁】</p></blockquote><p>那如果一个事务首先插入了一条记录（此时并没有在内存生产与该记录关联的锁结构)，然后另一个事务:</p><ul><li>立即使用<code>SELECT … LOCK IN SHARE MODE</code>语句读取这条记录，也就是要获取这条记录的<code>S锁</code>，或者使用<code>SELECT… FOR UPDATE</code>语句读取这条记录，也就是要获取这条记录的<code>X锁</code>，怎么办? 如果允许这种情况的发生，那么可能产生<code>脏读</code>问题。</li><li>立即修改这条记录，也就是要获取这条记录的<code>X锁</code>，怎么办? 如果允许这种情况的发生，那么可能产生<code>脏写</code>问题。</li></ul><p>这时候前边提过的<code>事务id</code>又要起作用了。把聚簇索引和二级索引中的记录分开看一下：（原理了解即可）</p><ul><li>情景一： 对于聚簇索引记录来说，有一个trx_id隐藏列，该隐藏列记录着最后改动该记录的事务id。那么如果在当前事务中新插入一条聚簇索引记录后，该记录的trx_id隐藏列代表的的就是当前事务的事务id，如果其他事务此时想对该记录添加S锁或者X锁时，首先会看一下该记录的trx_id隐藏列代表的事务是否是当前的活跃事务，如果是的话，那么就帮助当前事务创建一个X锁（也就是为当前事务创建一个锁结构，is_waiting属性是false），然后自己进入等待状态（也就是为自己也创建一个锁结构，is_waiting属性是true）。</li><li>情景二： 对于二级索引记录来说，本身并没有trx_id隐藏列，但是在二级索引页面的PageHeader部分有一个PAGE_MAX_TRX_ID属性，该属性代表对该页面做改动的最大的事务id，如果PAGE_MAX_TRX_ID属性值小于当前最小的活跃事务id，那么说明对该页面做修改的事务都已经提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记录，然后再重复情景一的做法。</li></ul><h2 id="即-一个事务对新插入的记录可以不显式的加锁-生成一个锁结构-但是由于事务id的存在-相当于加了一个隐式锁。别的事务在对这条记录加s锁或者x锁时-由于隐式锁的存在-会先帮助当前事务生成一个锁结构-然后自己再生成一个锁结构后进入等待状态。隐式锁是一种延迟加锁的机制-从而来减少加锁的数量。" tabindex="-1"><a class="header-anchor" href="#即-一个事务对新插入的记录可以不显式的加锁-生成一个锁结构-但是由于事务id的存在-相当于加了一个隐式锁。别的事务在对这条记录加s锁或者x锁时-由于隐式锁的存在-会先帮助当前事务生成一个锁结构-然后自己再生成一个锁结构后进入等待状态。隐式锁是一种延迟加锁的机制-从而来减少加锁的数量。" aria-hidden="true">#</a> 即：一个事务对新插入的记录可以不显式的加锁（生成一个锁结构），但是由于事务id的存在，相当于加了一个隐式锁。别的事务在对这条记录加S锁或者X锁时，由于隐式锁的存在，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构后进入等待状态。隐式锁是一种延迟加锁的机制，从而来减少加锁的数量。</h2><p>隐式锁在实际内存对象中并不含有这个锁信息。只有当产生锁等待时，隐式锁转化为显式锁。</p><p>InnoDB的insert操作，对插入的记录不加锁，但是此时如果另一个线程进行当前读，类似以下的用例，整个过程会发生什么呢 ?</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">############################SessionA#########################</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">begin</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">&gt;</span> <span class="token keyword">insert</span> <span class="token keyword">into</span> student <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token string">&#39;关羽&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;三班&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">#此时相当于会加个隐式锁</span>
Query OK<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token keyword">row</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

<span class="token comment">###########################SessionC###############################</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> performance_schema<span class="token punctuation">.</span>data_lock_waits\G<span class="token punctuation">;</span> <span class="token comment">#隐式锁是查不到的</span>
Empty <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

<span class="token comment">##########################SessionB################################</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">begin</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">&gt;</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share</span> <span class="token keyword">mode</span><span class="token punctuation">;</span>  <span class="token comment">#可以侧面得出结论，隐式锁是存在的~</span>
<span class="token comment">#阻塞... #阻塞也会导致A中的隐式锁转为显示锁</span>

<span class="token comment">##########################SessionC###################################</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> performance_schema<span class="token punctuation">.</span>data_lock_waits\G<span class="token punctuation">;</span> <span class="token comment">#查到由隐式锁转的显示锁</span>
<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token number">1.</span> <span class="token keyword">row</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>
                          <span class="token keyword">ENGINE</span>: <span class="token keyword">INNODB</span>
       REQUESTING_ENGINE_LOCK_ID: <span class="token number">140078105288944</span>:<span class="token number">47</span>:<span class="token number">4</span>:<span class="token number">10</span>:<span class="token number">140078009627240</span>
REQUESTING_ENGINE_TRANSACTION_ID: <span class="token number">421553081999600</span>
            REQUESTING_THREAD_ID: <span class="token number">49</span>
             REQUESTING_EVENT_ID: <span class="token number">25</span>
REQUESTING_OBJECT_INSTANCE_BEGIN: <span class="token number">140078009627240</span>
         BLOCKING_ENGINE_LOCK_ID: <span class="token number">140078105288088</span>:<span class="token number">47</span>:<span class="token number">4</span>:<span class="token number">10</span>:<span class="token number">140078009620736</span>
  BLOCKING_ENGINE_TRANSACTION_ID: <span class="token number">17430</span>
              BLOCKING_THREAD_ID: <span class="token number">49</span>
               BLOCKING_EVENT_ID: <span class="token number">25</span>
  BLOCKING_OBJECT_INSTANCE_BEGIN: <span class="token number">140078009620736</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>隐式锁的逻辑过程如下：</strong></p><p>A. InnoDB的每条记录中都一个隐含的<code>trx_id</code>字段，这个字段存在于聚簇索引的B+Tree中。</p><p>B. 在操作一条记录前，首先根据记录中的<code>trx_id</code>检查该事务是否是活动的事务(未提交或回滚)。如果是活动的事务，首先将 隐式锁 转换为 显式锁 (就是为该事务添加一个锁)。</p><p>C. 检查是否有锁冲突，如果有冲突，创建锁，并设置为<code>waiting</code>状态。如果没有冲突不加锁，跳到E。</p><p>D. 等待加锁成功，被唤醒，或者超时。</p><p>E. 写数据，并将自己的 <code>事务id</code> 写入trx_id字段。</p><h4 id="_2-显式锁" tabindex="-1"><a class="header-anchor" href="#_2-显式锁" aria-hidden="true">#</a> 2. 显式锁</h4><p>通过特定的语句进行加锁，我们一般称之为显示加锁，例如：</p><ul><li>显示加共享锁：</li></ul><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>select ....  lock in share mode
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>显示加排它锁：</li></ul><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>select ....  for update
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_3-5-其它锁之-全局锁" tabindex="-1"><a class="header-anchor" href="#_3-5-其它锁之-全局锁" aria-hidden="true">#</a> 3. 5 其它锁之：全局锁</h3><p>全局锁就是对<code>整个数据库实例</code>加锁。当你需要让整个库处于<code>只读状态</code>的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。全局锁的典型使用<code>场景</code>是：做<code>全库逻辑备份</code>。</p><p>全局锁的命令：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>Flush <span class="token keyword">tables</span> <span class="token keyword">with</span> <span class="token keyword">read</span> <span class="token keyword">lock</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_3-6-其它锁之-死锁" tabindex="-1"><a class="header-anchor" href="#_3-6-其它锁之-死锁" aria-hidden="true">#</a> 3. 6 其它锁之：死锁</h3><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。死锁示例：</p><table><thead><tr><th></th><th style="text-align:center;">事务1</th><th style="text-align:center;">事务2</th></tr></thead><tbody><tr><td>1</td><td style="text-align:center;">start transaction; update account set money=10 where id=1;</td><td style="text-align:center;">start transaction;</td></tr><tr><td>2</td><td style="text-align:center;"></td><td style="text-align:center;">update account set money=10 where id=2;</td></tr><tr><td>3</td><td style="text-align:center;">update account set money=20 where id=2;</td><td style="text-align:center;"></td></tr><tr><td>4</td><td style="text-align:center;"></td><td style="text-align:center;">update account set money=20 where id=1;</td></tr></tbody></table><p>这时候，事务 1 在等待事务 2 释放id=2的行锁，而事务 2 在等待事务 1 释放id=1的行锁。 事务 1 和事务 2 在互相等待对方的资源释放，就是进入了死锁状态。当出现死锁以后，有<code>两种策略</code>：</p><ul><li><p>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数<code>innodb_lock_wait_timeout</code>来设置。</p></li><li><p>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务（将持有最少行级排他锁的事务进行回滚），让其他事务得以继续执行。将参数<code>innodb_deadlock_detect</code>设置为on，表示开启这个逻辑。</p></li></ul><p>在InnoDB中，innodb_lock_wait_timeout的默认值是<code>50s</code>，意味着如果采用第一个策略，当出现死锁以后,第一个被锁住的线程要过50s才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。</p><p>但是，我们又不可能直接把这个时间设置成一个很小的值，比如1s。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。</p><p><strong>举例二：</strong></p><p>用户A给用户B转账100，在此同时，用户B也给用户A转账100。这个过程，可能导致死锁。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">#事务1</span>
<span class="token keyword">update</span> account <span class="token keyword">set</span> balance <span class="token operator">=</span> balance <span class="token operator">-</span> <span class="token number">108</span> <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">&#39;A&#39;</span><span class="token punctuation">;</span><span class="token comment">#操作1</span>
<span class="token keyword">update</span> account <span class="token keyword">set</span> balance <span class="token operator">=</span> balance <span class="token operator">+</span> <span class="token number">100</span> <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">&#39;B&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">#操作3</span>

<span class="token comment">#事务2</span>
<span class="token keyword">update</span> account <span class="token keyword">set</span> balance <span class="token operator">=</span> balance <span class="token operator">-</span> <span class="token number">100</span> <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">&#39;B&#39;</span><span class="token punctuation">;</span><span class="token comment">#操作2</span>
<span class="token keyword">update</span> account <span class="token keyword">set</span> balance <span class="token operator">=</span> balance <span class="token operator">+</span> <span class="token number">100</span> <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">&#39;A&#39;</span><span class="token punctuation">;</span><span class="token comment">#操作4</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="/assets/31c55ce4b568d260968a69d22539ecba.c480889e.png" alt="image-20230127162458138"></p><h4 id="_2-产生死锁的必要条件" tabindex="-1"><a class="header-anchor" href="#_2-产生死锁的必要条件" aria-hidden="true">#</a> 2. 产生死锁的必要条件</h4><ol><li>两个或者两个以上事务</li><li>每个事务都已经持有锁并且申请新的锁</li><li>锁资源同时只能被同一个事务持有或者不兼容</li><li>事务之间因为持有锁和申请锁导致彼此循环等待</li></ol><blockquote><p>死锁的关键在于:两个(或以上)的Session加锁的顺序不一致。</p></blockquote><p><strong>演示—死锁</strong></p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">#####################################SessionA########################</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">begin</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">&gt;</span> <span class="token keyword">update</span> account <span class="token keyword">set</span> balance <span class="token operator">=</span> balance <span class="token operator">-</span> <span class="token number">10</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">#为1d=1的加X锁</span>
Query OK<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token keyword">row</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>
<span class="token keyword">Rows</span> <span class="token keyword">matched</span>: <span class="token number">1</span>  Changed: <span class="token number">1</span>  <span class="token keyword">Warnings</span>: <span class="token number">0</span>

<span class="token comment">###################################SessionB########################</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">begin</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">&gt;</span> <span class="token keyword">update</span> account <span class="token keyword">set</span> balance <span class="token operator">=</span> balance <span class="token operator">-</span> <span class="token number">10</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">#为id=3的加X锁</span>
Query OK<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token keyword">row</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>
<span class="token keyword">Rows</span> <span class="token keyword">matched</span>: <span class="token number">1</span>  Changed: <span class="token number">1</span>  <span class="token keyword">Warnings</span>: <span class="token number">0</span>

<span class="token comment">######################################SessionA###########################</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">update</span> account <span class="token keyword">set</span> balance <span class="token operator">=</span> balance <span class="token operator">+</span> <span class="token number">10</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">#想要获取id为3的X锁</span>
<span class="token comment">#阻塞...</span>

<span class="token comment">#####################################SessionB####################</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">update</span> account <span class="token keyword">set</span> balance <span class="token operator">=</span> balance <span class="token operator">+</span> <span class="token number">10</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">#想要获取id为1的X锁</span>
ERROR <span class="token number">1213</span> <span class="token punctuation">(</span><span class="token number">40001</span><span class="token punctuation">)</span>: Deadlock found <span class="token keyword">when</span> trying <span class="token keyword">to</span> get <span class="token keyword">lock</span><span class="token punctuation">;</span> <span class="token comment">#出现死锁</span>

<span class="token comment">#################################SessionA############################</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">update</span> account <span class="token keyword">set</span> balance <span class="token operator">=</span> balance <span class="token operator">+</span> <span class="token number">10</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">#阻塞解开，继续执行</span>
Query OK<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token keyword">row</span> affected <span class="token punctuation">(</span><span class="token number">18.39</span> sec<span class="token punctuation">)</span> <span class="token comment"># 具体死锁为啥会被解开，下面会讲哦~</span>
<span class="token keyword">Rows</span> <span class="token keyword">matched</span>: <span class="token number">1</span>  Changed: <span class="token number">1</span>  <span class="token keyword">Warnings</span>: <span class="token number">0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_3-如何处理死锁" tabindex="-1"><a class="header-anchor" href="#_3-如何处理死锁" aria-hidden="true">#</a> 3. 如何处理死锁</h4><p><strong>方式1：</strong> 等待，直到超时( innodb_lock_wait_timeout=50s)</p><p>即当两个事务互相等待时，当一个事务等待时间超过设置的阈值时，就将其<code>回滚</code>，另外事务继续进行。这种方法简单有效，在innodb中，参数<code>innodb_lock_wait_timeout</code>用来设置超时时间。</p><p>缺点：对于在线服务来说，这个等待时间往往是无法接受的。</p><p>那将此值修改短一些，比如1s，0.1s是否合适？不合适，容易误伤到普通的锁等待。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>mysql<span class="token operator">&gt;</span> <span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">&#39;innodb_lock_wait_timeout&#39;</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">--------------------------+-------+</span>
<span class="token operator">|</span> Variable_name            <span class="token operator">|</span> <span class="token keyword">Value</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">--------------------------+-------+</span>
<span class="token operator">|</span> innodb_lock_wait_timeout <span class="token operator">|</span> <span class="token number">50</span>    <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">--------------------------+-------+</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>**方式2：**使用死锁检测进行死锁处理</p><p>方式1检测死锁太过被动，innodb还提供了wait-for graph算法来主动进行死锁检测，每当加锁请求无法立即满足需要并进入等待时，wait-for graph算法都会被触发。</p><p>这是一种较为主动的死锁检测机制，要求数据库保存锁的信息链表和事务等待链表两部分信息。</p><p><img src="/assets/d6a20bbe6f0376c42f1abe2e35339882.12c9230c.png" alt="image-20230127163322402"></p><p>基于这两个信息，可以绘制wait-for graph 等待图</p><p><img src="/assets/651ace1541098295cb19738b053d0078.b1f17134.png" alt="image-20230127163339663"></p><blockquote><p>死锁检测的原理是构建一个以<code>事务为顶点、锁为边的有向图</code>，判断有向图是否存在<code>环</code>，存在即有死锁</p></blockquote><p>一旦检测到<code>回路</code>、有死锁，这时候InnoDB存储引擎会选择<code>回滚undo量最小的事务</code>，让其他事务继续执行( <code>innodb_deadlock_detect=on</code>表示开启这个逻辑)。</p><p>缺点：每个新的被阻塞的线程，都要判断是不是由于自己的加入导致了死锁，这个操作时间复杂度是O(n)。如果100个并发线程同时更新同一行，意味着要检测100*100= 1万次，1万个线程就会有1千万次检测。</p><p><strong>如何解决？</strong></p><ul><li>方式1：关闭死锁检测，但意味着可能会出现大量的超时，会导致业务有损。</li><li>方式2：控制并发访问的数量。比如在中间件中实现对于相同行的更新，在进入引擎之前排队，这样在InnoDB内部就不会有大量的死锁检测工作</li></ul><blockquote><p>进一步的思路：可以考虑通过<code>将一行改成逻辑上的多行</code>来减少锁冲突。比如，连锁超市账户总额的记录，可以考虑放到多条记录上。账户总额等于这多个记录的值的总和。</p></blockquote><h4 id="_4-如何避免死锁" tabindex="-1"><a class="header-anchor" href="#_4-如何避免死锁" aria-hidden="true">#</a> 4. 如何避免死锁</h4><ul><li><p><code>合理设计索引</code>，使业务SQL尽可能通过索引定位更少的行，减少锁竞争。</p></li><li><p><code>调整业务逻辑SQL执行顺序</code>，避免update/delete长时间持有锁的SQL在事务前面。</p></li><li><p>避免大事务，<code>尽量将大事务拆成多个小事务来处理</code>，小事务缩短锁定资源的时间，发生锁冲突的几率也更小</p></li><li><p><code>在并发比较高的系统中，不要显式加锁</code>，特别是是在事务里显式加锁。如select … for</p><p>update语句，如果是在事务里运行了start transaction或设置了autocommit等于0，那么就会锁定所查找到的记录</p></li><li><p><code>降低隔离级别</code>。如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁。</p></li></ul><h2 id="_4-锁的内存结构" tabindex="-1"><a class="header-anchor" href="#_4-锁的内存结构" aria-hidden="true">#</a> 4. 锁的内存结构</h2><p>前边说对一条记录加锁的本质就是在内存中创建一个<code>锁结构</code>与之关联，那么是不是一个事务对多条记录加锁，就要创建多个<code>锁结构</code>呢?比如:</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">#事务T1</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">LOCK</span> <span class="token operator">IN</span> <span class="token keyword">SHARE</span> <span class="token keyword">MODE</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>理论上创建多个<code>锁结构</code>没问题，但是如果一个事务要获取10000条记录的锁，生成10000个锁结构也太崩溃了! 所以决定在对不同记录加锁时，如果符合下边这些条件的记录会放到一个<code>锁结构</code>中。</p><ul><li>在同一个事务中进行加锁操作</li><li>被加锁的记录在同一个页面中</li><li>加锁的类型是一样的</li><li>等待状态是一样的</li></ul><p><code>InnoDB</code>存储引擎中的<code>锁结构</code>如下:</p><p><img src="/assets/26795a7709c47451253230e42873d973.c35427a5.png" alt="image-20230127222432726"></p><p>结构解析：</p><ol><li><p>锁所在的事务信息：</p><p>不论是<code>表锁</code>还是<code>行锁</code>，都是在事务执行过程中生成的，哪个事务生成了这个<code>锁结构</code>，这里就记录这个事务的信息。</p><p>此<code>锁所在的事务信息</code>在内存结构中只是一个指针，通过指针可以找到内存中关于该事务的更多信息，比方说事务id等。</p></li><li><p>索引信息：</p><p>对于行锁来说，需要记录一下加锁的记录是属于哪个索引的。这里也是一个指针。</p></li><li><p>表锁／行锁信息：</p><p><code>表锁结构</code>和<code>行锁结构</code>在这个位置的内容是不同的：</p><ul><li><p>表锁：</p><p>记载着是对哪个表加的锁，还有其他的一些信息。</p></li><li><p>行锁：</p><p>记载了三个重要的信息：</p><ul><li><p>Space ID：记录所在表空间。</p></li><li><p>Page Number：记录所在页号。</p></li><li><p>n_bits：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同的比特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，这个n_bits属性代表使用了多少比特位。</p><blockquote><p>n_bits的值一般都比页面中记录条数多一些。主要是为了之后在页面中插入了新记录后 也不至于重新分配锁结构</p></blockquote></li></ul></li></ul></li><li><p>type_mode：</p><p>这是一个 32 位的数，被分成了lock_mode、lock_type和rec_lock_type三个部分，如图所示：</p><p><img src="/assets/f70f47c646148330875c9b1bd0259ba9.d04da1dc.png" alt="image-20230127222846678"></p></li></ol><ul><li><p>锁的模式（lock_mode），占用低 4 位，可选的值如下：</p><ul><li>LOCK_IS（十进制的 0 ）：表示共享意向锁，也就是IS锁。</li><li>LOCK_IX（十进制的 1 ）：表示独占意向锁，也就是IX锁。</li><li>LOCK_S（十进制的 2 ）：表示共享锁，也就是S锁。</li><li>LOCK_X（十进制的 3 ）：表示独占锁，也就是X锁。</li><li>LOCK_AUTO_INC（十进制的 4 ）：表示AUTO-INC锁。</li></ul><blockquote><p>在InnoDB存储引擎中，LOCK_IS，LOCK_IX，LOCK_AUTO_INC都算是表级锁的模式，LOCK_S和LOCK_X既可以算是表级锁的模式，也可以是行级锁的模式。</p></blockquote></li><li><p>锁的类型（lock_type），占用第 5 ～ 8 位，不过现阶段只有第 5 位和第 6 位被使用：</p><ul><li>LOCK_TABLE（十进制的 16 ），也就是当第 5 个比特位置为 1 时，表示表级锁。</li><li>LOCK_REC（十进制的 32 ），也就是当第 6 个比特位置为 1 时，表示行级锁。</li></ul></li><li><p>行锁的具体类型（rec_lock_type），使用其余的位来表示。只有在lock_type的值为</p><ul><li>LOCK_REC时，也就是只有在该锁为行级锁时，才会被细分为更多的类型：</li><li>LOCK_ORDINARY（十进制的 0 ）：表示next-key锁。</li><li>LOCK_GAP（十进制的 512 ）：也就是当第 10 个比特位置为 1 时，表示gap锁。</li><li>LOCK_REC_NOT_GAP（十进制的 1024 ）：也就是当第 11 个比特位置为 1 时，表示正经记录锁。</li><li>LOCK_INSERT_INTENTION（十进制的 2048 ）：也就是当第 12 个比特位置为 1 时，表示插入意向锁。其他的类型：还有一些不常用的类型我们就不多说了。</li></ul></li><li><p>is_waiting属性呢？基于内存空间的节省，所以把is_waiting属性放到了type_mode这个 32位的数字中：</p><ul><li>LOCK_WAIT（十进制的 256 ） ：当第 9 个比特位置为 1 时，表示is_waiting为true，也就是当前事务尚未获取到锁，处在等待状态；当这个比特位为 0 时，表示is_waiting为false，也就是当前事务获取锁成功。</li></ul></li></ul><ol start="5"><li><p>其他信息：</p><p>为了更好的管理系统运行过程中生成的各种锁结构而设计了各种哈希表和链表。</p></li><li><p>一堆比特位：</p><p>如果是<code>行锁结构</code>的话，在该结构末尾还放置了一堆比特位，比特位的数量是由上边提到的n_bits属性表示的。InnoDB数据页中的每条记录在记录头信息中都包含一个heap_no属性，伪记录Infimum的heap_no值为 0 ，Supremum的heap_no值为 1 ，之后每插入一条记录，heap_no值就增 1 。锁结构最后的一堆比特位就对应着一个页面中的记录，一个比特位映射一个heap_no，即一个比特位映射到页内的一条记录。</p></li></ol><h2 id="_5-锁监控" tabindex="-1"><a class="header-anchor" href="#_5-锁监控" aria-hidden="true">#</a> 5. 锁监控</h2><p>关于MySQL锁的监控，我们一般可以通过检查<code>InnoDB_row_lock</code>等状态变量来分析系统上的行锁的争夺情况</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>mysql&gt; show status like &#39;innodb_row_lock%&#39;;
+-------------------------------+-------+
| Variable_name | Value |
+-------------------------------+-------+
| Innodb_row_lock_current_waits | 0 |
| Innodb_row_lock_time | 0 |
| Innodb_row_lock_time_avg | 0 |
| Innodb_row_lock_time_max | 0 |
| Innodb_row_lock_waits | 0 |
+-------------------------------+-------+
5 rows in set (0.01 sec)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="对各个状态量的说明如下" tabindex="-1"><a class="header-anchor" href="#对各个状态量的说明如下" aria-hidden="true">#</a> 对各个状态量的说明如下：</h5><ul><li>Innodb_row_lock_current_waits：当前正在等待锁定的数量；</li><li>Innodb_row_lock_time：从系统启动到现在锁定总时间长度；（等待总时长）</li><li>Innodb_row_lock_time_avg：每次等待所花平均时间；（等待平均时长）</li><li>Innodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间；</li><li>Innodb_row_lock_waits：系统启动后到现在总共等待的次数；（等待总次数）</li></ul><p>对于这 5 个状态变量，比较重要的 3 个见上面（橙色）。</p><p><strong>其他监控方法：</strong></p><p>MySQL把事务和锁的信息记录在了<code>information_schema</code>库中，涉及到的三张表分别是<code>INNODB_TRX</code>、<code>INNODB_LOCKS</code>和<code>INNODB_LOCK_WAITS</code>。</p><p><code>MySQL5.7</code>及之前，可以通过information_schema.INNODB_LOCKS查看事务的锁情况，但只能看到阻塞事务的锁；如果事务并未被阻塞，则在该表中看不到该事务的锁情况。</p><p>MySQL8.0删除了information_schema.INNODB_LOCKS，添加了<code>performance_schema.data_locks</code>，可以通过performance_schema.data_locks查看事务的锁情况，和MySQL5.7及之前不同，<code>performance_schema.data_locks</code>不但可以看到阻塞该事务的锁，还可以看到该事务所持有的锁。</p><p>同时，information_schema.INNODB_LOCK_WAITS也被<code>performance_schema.data_lock_waits</code>所代替。</p><p>我们模拟一个锁等待的场景，以下是从这三张表收集的信息</p><p>锁等待场景，我们依然使用记录锁中的案例，当事务 2 进行等待时，查询情况如下：</p><p>（ 1 ）查询正在被锁阻塞的sql语句。</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>SELECT * FROM information_schema.INNODB_TRX\G;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>重要属性代表含义已在上述中标注。</p><p>（ 2 ）查询锁等待情况</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>SELECT * FROM data_lock_waits\G;
*************************** 1. row ***************************
ENGINE: INNODB
REQUESTING_ENGINE_LOCK_ID: 139750145405624 :7:4:7:
REQUESTING_ENGINE_TRANSACTION_ID: 13845 #被阻塞的事务ID
REQUESTING_THREAD_ID: 72
REQUESTING_EVENT_ID: 26
REQUESTING_OBJECT_INSTANCE_BEGIN: 139747028690608
BLOCKING_ENGINE_LOCK_ID: 139750145406432 :7:4:7:
BLOCKING_ENGINE_TRANSACTION_ID: 13844 #正在执行的事务ID，阻塞了 13845
BLOCKING_THREAD_ID: 71
BLOCKING_EVENT_ID: 24
BLOCKING_OBJECT_INSTANCE_BEGIN: 139747028813248
1 row in set (0.00 sec)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（ 3 ）查询锁的情况</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>mysql &gt; SELECT * from performance_schema.data_locks\G;
*************************** 1. row ***************************
ENGINE: INNODB
ENGINE_LOCK_ID: 139750145405624 :1068:
ENGINE_TRANSACTION_ID: 13847
THREAD_ID: 72
EVENT_ID: 31
OBJECT_SCHEMA: atguigu
OBJECT_NAME: user
PARTITION_NAME: NULL
SUBPARTITION_NAME: NULL
INDEX_NAME: NULL
OBJECT_INSTANCE_BEGIN: 139747028693520
LOCK_TYPE: TABLE
LOCK_MODE: IX
LOCK_STATUS: GRANTED
LOCK_DATA: NULL
*************************** 2. row ***************************
ENGINE: INNODB
ENGINE_LOCK_ID: 139750145405624 :7:4:7:
ENGINE_TRANSACTION_ID: 13847
THREAD_ID: 72
EVENT_ID: 31
OBJECT_SCHEMA: atguigu
OBJECT_NAME: user
PARTITION_NAME: NULL
SUBPARTITION_NAME: NULL
INDEX_NAME: PRIMARY
OBJECT_INSTANCE_BEGIN: 139747028690608
LOCK_TYPE: RECORD
LOCK_MODE: X,REC_NOT_GAP
LOCK_STATUS: WAITING
LOCK_DATA: 1
*************************** 3. row ***************************
ENGINE: INNODB
ENGINE_LOCK_ID: 139750145406432 :1068:
ENGINE_TRANSACTION_ID: 13846
THREAD_ID: 71
EVENT_ID: 28
OBJECT_SCHEMA: atguigu
OBJECT_NAME: user
PARTITION_NAME: NULL
SUBPARTITION_NAME: NULL
INDEX_NAME: NULL
OBJECT_INSTANCE_BEGIN: 139747028816304
LOCK_TYPE: TABLE

LOCK_MODE: IX
LOCK_STATUS: GRANTED
LOCK_DATA: NULL
*************************** 4. row ***************************
ENGINE: INNODB
ENGINE_LOCK_ID: 139750145406432 :7:4:7:
ENGINE_TRANSACTION_ID: 13846
THREAD_ID: 71
EVENT_ID: 28
OBJECT_SCHEMA: atguigu
OBJECT_NAME: user
PARTITION_NAME: NULL
SUBPARTITION_NAME: NULL
INDEX_NAME: PRIMARY
OBJECT_INSTANCE_BEGIN: 139747028813248
LOCK_TYPE: RECORD
LOCK_MODE: X,REC_NOT_GAP
LOCK_STATUS: GRANTED
LOCK_DATA: 1
4 rows in set (0.00 sec)

ERROR:
No query specified
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从锁的情况可以看出来，两个事务分别获取了IX锁，我们从意向锁章节可以知道，IX锁互相时兼容的。所以这里不会等待，但是事务 1 同样持有X锁，此时事务 2 也要去同一行记录获取X锁，他们之间不兼容，导致等待的情况发生。</p><h2 id="_6-附录" tabindex="-1"><a class="header-anchor" href="#_6-附录" aria-hidden="true">#</a> 6. 附录</h2><h5 id="间隙锁加锁规则-共-11-个案例" tabindex="-1"><a class="header-anchor" href="#间隙锁加锁规则-共-11-个案例" aria-hidden="true">#</a> 间隙锁加锁规则（共 11 个案例）</h5><p>间隙锁是在可重复读隔离级别下才会生效的： next-key lock 实际上是由间隙锁加行锁实现的，如果切换到读提交隔离级别 (read-committed) 的话，就好理解了，过程中去掉间隙锁的部分，也就是只剩下行锁的部分。而在读提交隔离级别下间隙锁就没有了，为了解决可能出现的数据和日志不一致问题，需要把binlog 格式设置为 row 。也就是说，许多公司的配置为：读提交隔离级别加 binlog_format=row。业务不需要可重复读的保证，这样考虑到读提交下操作数据的锁范围更小（没有间隙锁），这个选择是合理的。</p><p>next-key lock的加锁规则</p><p>总结的加锁规则里面，包含了两个 “ “ 原则 ” ” 、两个 “ “ 优化 ” ” 和一个 “bug” 。</p><ol><li><p>原则 1 ：加锁的基本单位是 next-key lock 。 next-key lock 是前开后闭区间。</p></li><li><p>原则 2 ：查找过程中访问到的对象才会加锁。任何辅助索引上的锁，或者非索引列上的锁，最终 都要回溯到主键上，在主键上也要加一把锁。</p></li><li><p>优化 1 ：索引上的等值查询，给唯一索引加锁的时候， next-key lock 退化为行锁。也就是说如果 InnoDB扫描的是一个主键、或是一个唯一索引的话，那InnoDB只会采用行锁方式来加锁</p></li><li><p>优化 2 ：索引上（不一定是唯一索引）的等值查询，向右遍历时且最后一个值不满足等值条件的 时候， next-keylock 退化为间隙锁。</p></li><li><p>一个 bug ：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</p></li></ol><p>我们以表test作为例子，建表语句和初始化语句如下：其中id为主键索引</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>CREATE TABLE `test` (
`id` int( 11 ) NOT NULL,
`col1` int( 11 ) DEFAULT NULL,
`col2` int( 11 ) DEFAULT NULL,
PRIMARY KEY (`id`),
KEY `c` (`c`)
) ENGINE=InnoDB;
insert into test values( 0 , 0 , 0 ),( 5 , 5 , 5 ),
( 10 , 10 , 10 ),( 15 , 15 , 15 ),( 20 , 20 , 20 ),( 25 , 25 , 25 );
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="案例一-唯一索引等值查询间隙锁" tabindex="-1"><a class="header-anchor" href="#案例一-唯一索引等值查询间隙锁" aria-hidden="true">#</a> 案例一：唯一索引等值查询间隙锁</h5><p>由于表 test 中没有 id=7 的记录</p><p>根据原则 1 ，加锁单位是 next-key lock ， session A 加锁范围就是 (5,10] ； 同时根据优化 2 ，这是一个等值查询 (id=7) ，而 id=10 不满足查询条件， next-key lock 退化成间隙锁，因此最终加锁的范围是 (5,10)</p><p><strong>案例二：非唯一索引等值查询锁</strong></p><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionC</th></tr></thead><tbody><tr><td>begin; select id from test where col1 = 5 lock in share mode;</td><td></td><td></td></tr><tr><td></td><td>update test col2 = col2+1 where id=5; (Query OK)</td><td></td></tr><tr><td></td><td></td><td>insert into test values(7,7,7) (blocked)</td></tr></tbody></table><p>这里 session A 要给索引 col1 上 col1=5 的这一行加上读锁。</p><ol><li>根据原则 1 ，加锁单位是 next-key lock ，左开右闭， 5 是闭上的，因此会给 (0,5] 加上 next-key lock。</li><li>要注意 c 是普通索引，因此仅访问 c=5 这一条记录是不能马上停下来的（可能有col1=5的其他记录），需要向右遍历，查到c=10 才放弃。根据原则 2 ，访问到的都要加锁，因此要给 (5,10] 加next-key lock 。</li><li>但是同时这个符合优化 2 ：等值判断，向右遍历，最后一个值不满足 col1=5 这个等值条件，因此退化成间隙锁 (5,10) 。</li><li>根据原则 2 ， 只有访问到的对象才会加锁，这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引上没有加任何锁，这就是为什么 session B 的 update 语句可以执行完成。</li></ol><p>但 session C 要插入一个 (7,7,7) 的记录，就会被 session A 的间隙锁 (5,10) 锁住 这个例子说明，锁是加在索引上的。</p><p>执行 for update 时，系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁。</p><p>如果你要用 lock in share mode来给行加读锁避免数据被更新的话，就必须得绕过覆盖索引的优化，因为覆盖索引不会访问主键索引，不会给主键索引上加锁</p><p><strong>案例三：主键索引范围查询锁</strong></p><p>上面两个例子是等值查询的，这个例子是关于范围查询的，也就是说下面的语句</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> test <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">10</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tets <span class="token keyword">where</span> id<span class="token operator">&gt;=</span> <span class="token number">10</span> <span class="token operator">and</span> id<span class="token operator">&lt;</span> <span class="token number">11</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这两条查语句肯定是等价的，但是它们的加锁规则不太一样</p><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionC</th></tr></thead><tbody><tr><td>begin; select * from test where id&gt;= 10 and id&lt;11 for update;</td><td></td><td></td></tr><tr><td></td><td>insert into test values(8,8,8) (Query OK) insert into test values(13,13,13); (blocked)</td><td></td></tr><tr><td></td><td></td><td>update test set clo2=col2+1 where id=15; (blocked)</td></tr></tbody></table><ol><li>开始执行的时候，要找到第一个 id=10 的行，因此本该是 next-key lock(5,10] 。 根据优化 1 ，主键id 上的等值条件，退化成行锁，只加了 id=10 这一行的行锁。</li><li>它是范围查询， 范围查找就往后继续找，找到 id=15 这一行停下来，不满足条件，因此需要加next-key lock(10,15] 。</li></ol><p>session A 这时候锁的范围就是主键索引上，行锁 id=10 和 next-key lock(10,15] 。 <strong>首次 session A 定位查找id=10 的行的时候，是当做等值查询来判断的，而向右扫描到 id=15 的时候，用的是范围查询判断。</strong></p><p><strong>案例四：非唯一索引范围查询锁</strong></p><p>与案例三不同的是，案例四中查询语句的 where 部分用的是字段 c ，它是普通索引</p><p>这两条查语句肯定是等价的，但是它们的加锁规则不太一样</p><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionC</th></tr></thead><tbody><tr><td>begin; select * from test where col1&gt;= 10 and col1&lt;11 for update;</td><td></td><td></td></tr><tr><td></td><td>insert into test values(8,8,8)(blocked)</td><td></td></tr><tr><td></td><td></td><td>update test set clo2=col2+1 where id=15; (blocked)</td></tr></tbody></table><p>在第一次用 col1=10 定位记录的时候，索引 c 上加了 (5,10] 这个 next-key lock 后，由于索引 col1 是非唯一索引，没有优化规则，也就是 说不会蜕变为行锁，因此最终 sesion A 加的锁是，索引 c 上的 (5,10] 和(10,15] 这两个 next-keylock 。</p><p>这里需要扫描到 col1=15 才停止扫描，是合理的，因为 InnoDB 要扫到 col1=15 ，才知道不需要继续往后找了。</p><p><strong>案例五：唯一索引范围查询锁 bug</strong></p><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionC</th></tr></thead><tbody><tr><td>begin; select * from test where id&gt; 10 and id&lt;=15 for update;</td><td></td><td></td></tr><tr><td></td><td>update test set clo2=col2+1 where id=20; (blocked)</td><td></td></tr><tr><td></td><td></td><td>insert into test values(16,16,16); (blocked)</td></tr></tbody></table><p>session A 是一个范围查询，按照原则 1 的话，应该是索引 id 上只加 (10,15] 这个 next-key lock ，并且因为 id 是唯一键，所以循环判断到 id=15 这一行就应该停止了。</p><p>但是实现上， InnoDB 会往前扫描到第一个不满足条件的行为止，也就是 id=20 。而且由于这是个范围扫描，因此索引 id 上的 (15,20] 这个 next-key lock 也会被锁上。照理说，这里锁住 id=20 这一行的行为，其实是没有必要的。因为扫描到 id=15 ，就可以确定不用往后再找了。</p><p><strong>案例六：非唯一索引上存在 &quot; &quot; 等值 &quot; &quot; 的例子</strong></p><p>这里，我给表 t 插入一条新记录：insert into t values(30,10,30);也就是说，现在表里面有两个c=10的行</p><p><strong>但是它们的主键值 id 是不同的（分别是 10 和 30 ），因此这两个c=10 的记录之间，也是有间隙的。</strong></p><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionC</th></tr></thead><tbody><tr><td>begin; delete from test where col1=10;</td><td></td><td></td></tr><tr><td></td><td>insert into test values(12,12,12); (blocked)</td><td></td></tr><tr><td></td><td></td><td>update test set col2=col2+1where c=15; (blocked)</td></tr></tbody></table><p>这次我们用 delete 语句来验证。注意， delete 语句加锁的逻辑，其实跟 select ... for update 是类似的，也就是我在文章开始总结的两个 “ 原则 ” 、两个 “ 优化 ” 和一个 “bug” 。</p><p>这时， session A 在遍历的时候，先访问第一个 col1=10 的记录。同样地，根据原则 1 ，这里加的是(col1=5,id=5) 到 (col1=10,id=10) 这个 next-key lock 。</p><p>由于c是普通索引，所以继续向右查找，直到碰到 (col1=15,id=15) 这一行循环才结束。根据优化 2 ，这是一个等值查询，向右查找到了不满足条件的行，所以会退化成 (col1=10,id=10) 到 (col1=15,id=15) 的间隙锁。</p><p>这个 delete 语句在索引 c 上的加锁范围，就是上面图中蓝色区域覆盖的部分。这个蓝色区域左右两边都 是虚线，表示开区间，即 (col1=5,id=5) 和 (col1=15,id=15) 这两行上都没有锁</p><p><strong>案例七： limit 语句加锁</strong></p><p>例子 6 也有一个对照案例，场景如下所示：</p><table><thead><tr><th>sessionA</th><th>sessionB</th></tr></thead><tbody><tr><td>begin; delete from test where col1=10 limit 2;</td><td></td></tr><tr><td></td><td>insert into test values(12,12,12); (Query OK)</td></tr></tbody></table><p>session A 的 delete 语句加了 limit 2 。你知道表 t 里 c=10 的记录其实只有两条，因此加不加 limit 2 ，删除的效果都是一样的。但是加锁效果却不一样</p><p>这是因为，案例七里的 delete 语句明确加了 limit 2 的限制，因此在遍历到 (col1=10, id=30) 这一行之后，满足条件的语句已经有两条，循环就结束了。因此，索引 col1 上的加锁范围就变成了从（ col1=5,id=5)到（ col1=10,id=30) 这个前开后闭区间，如下图所示：</p><p>这个例子对我们实践的指导意义就是， 在删除数据的时候尽量加 limit 。</p><p>这样不仅可以 <strong>控制删除数据的条数，让操作更安全，还可以减小加锁的范围。</strong></p><p><strong>案例八：一个死锁的例子</strong></p><table><thead><tr><th>sessionA</th><th>sessionB</th></tr></thead><tbody><tr><td>begin; select id from test where col1=10 lock in share mode;</td><td></td></tr><tr><td></td><td>update test set col2=col2+1 where c=10; (blocked)</td></tr><tr><td>insert into test values(8,8,8);</td><td></td></tr><tr><td></td><td>ERROR 1213(40001):Deadlock found when trying to getlock;try restarting transaction</td></tr></tbody></table><ol><li>session A 启动事务后执行查询语句加 lock in share mode ，在索引 col1 上加了 next-keylock(5,10] 和间隙锁 (10,15) （索引向右遍历退化为间隙锁）；</li><li>session B 的 update 语句也要在索引 c 上加 next-key lock(5,10] ，进入锁等待； 实际上分成了两步，先是加 (5,10) 的间隙锁，加锁成功；然后加 col1=10 的行锁，因为sessionA上已经给这行加上了读锁，此时申请死锁时会被阻塞</li><li>然后 session A 要再插入 (8,8,8) 这一行，被 session B 的间隙锁锁住。由于出现了死锁， InnoDB 让session B 回滚</li></ol><p><strong>案例九：order by索引排序的间隙锁 1</strong></p><p>如下面一条语句</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>begin;
select * from test where id&gt;9 and id&lt;12 order by id desc for update;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>下图为这个表的索引id的示意图。</p><ol><li><p>首先这个查询语句的语义是 order by id desc ，要拿到满足条件的所有行，优化器必须先找到 “ 第一个 id&lt;12 的值 ” 。</p></li><li><p>这个过程是通过索引树的搜索过程得到的，在引擎内部，其实是要找到 id=12 的这个值，只是最终没找到，但找到了 (10,15) 这个间隙。（ id=15 不满足条件，所以 next-key lock 退化为了间隙锁 (10,15) 。）</p></li><li><p>然后向左遍历，在遍历过程中，就不是等值查询了，会扫描到 id=5 这一行，又因为区间是左开右闭的，所以会加一个next-key lock (0,5] 。 也就是说，在执行过程中，通过树搜索的方式定位记录的时候，用的是 “ 等值查询 ” 的方法。</p></li></ol><p><strong>案例十：order by索引排序的间隙锁 2</strong></p><table><thead><tr><th>sessionA</th><th>sessionB</th></tr></thead><tbody><tr><td>begin; select * from test where col1&gt;=15 and c&lt;=20 order by col1 desc lock in share mode;</td><td></td></tr><tr><td></td><td>insert into test values(6,6,6); (blocked)</td></tr></tbody></table><ol><li>由于是 order by col1 desc ，第一个要定位的是索引 col1 上 “ 最右边的 ”col1=20 的行。这是一个非 唯一索引的等值查询：</li></ol><p>左开右闭区间，首先加上 next-key lock (15,20] 。 向右遍历，col1=25不满足条件，退化为间隙锁 所以会加上间隙锁(20,25) 和 next-key lock (15,20] 。</p><ol start="2"><li>在索引 col1 上向左遍历，要扫描到 col1=10 才停下来。同时又因为左开右闭区间，所以 next-key lock 会加到 (5,10] ，这正是阻塞session B 的 insert 语句的原因。</li><li>在扫描过程中， col1=20 、 col1=15 、 col1=10 这三行都存在值，由于是 select * ，所以会在主键 id 上加三个行锁。 因此， session A 的 select 语句锁的范围就是：</li><li>索引 col1 上 (5, 25) ；</li><li>主键索引上 id=15 、 20 两个行锁。</li></ol><p><strong>案例十一：update修改数据的例子-先插入后删除</strong></p><table><thead><tr><th>sessionA</th><th>sessionB</th></tr></thead><tbody><tr><td>begin; select col1 from test where col1&gt;5 lock in share mode;</td><td></td></tr><tr><td></td><td>update test set col1=1 where col1=5 (Query OK) update test set col1=5 where col1=1; (blocked)</td></tr></tbody></table><p>注意：根据 col1&gt;5 查到的第一个记录是 col1=10 ，因此不会加 (0,5] 这个 next-key lock 。</p><p>session A 的加锁范围是索引 col1 上的 (5,10] 、 (10,15] 、 (15,20] 、 (20,25] 和(25,supremum] 。</p><p>之后 session B 的第一个 update 语句，要把 col1=5 改成 col1=1 ，你可以理解为两步：</p><ol><li>插入 (col1=1, id=5) 这个记录；</li><li>删除 (col1=5, id=5) 这个记录。</li></ol><p>通过这个操作， session A 的加锁范围变成了图 7 所示的样子：</p><p>好，接下来 session B 要执行 update t set col1 = 5 where col1 = 1 这个语句了，一样地可以拆成两步：</p><ol><li>插入 (col1=5, id=5) 这个记录；</li><li>删除 (col1=1, id=5) 这个记录。 第一步试图在已经加了间隙锁的 (1,10) 中插入数据，所以就被堵住了。</li></ol></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/Ragnarokoo/LearningNotes/edit/master/src/notes/db/mysql_pro/第15章_锁.md" rel="noopener noreferrer" target="_blank" aria-label="在【Github】上编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->在【Github】上编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><!----></div><!----></footer><nav class="page-nav"><a href="/notes/db/mysql_pro/%E7%AC%AC14%E7%AB%A0_MySQL%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97.html" class="nav-link prev" aria-label="第14章_MySQL事务日志"><div class="hint"><span class="arrow left"></span>上一页</div><div class="link"><!---->第14章_MySQL事务日志</div></a><a href="/notes/db/mysql_pro/%E7%AC%AC16%E7%AB%A0_%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6.html" class="nav-link next" aria-label="第 16 章_多版本并发控制"><div class="hint">下一页<span class="arrow right"></span></div><div class="link">第 16 章_多版本并发控制<!----></div></a></nav><!----><!----><!--]--></main><!--]--><!----><!--]--></div><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app.9b10ba0a.js" defer></script>
  </body>
</html>
