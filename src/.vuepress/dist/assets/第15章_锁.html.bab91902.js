const e=JSON.parse('{"key":"v-554c50ee","path":"/notes/db/mysql_pro/%E7%AC%AC15%E7%AB%A0_%E9%94%81.html","title":"第 15 章_锁","lang":"zh-CN","frontmatter":{"title":"第 15 章_锁","category":["mysql"],"tag":["mysql","SQL","关系型数据库"],"sticky":false,"star":false,"article":true,"timeline":true,"description":"事务的隔离性由这章讲述的锁来实现。 1. 概述 锁是计算机协调多个进程或线程并发访问某一资源的机制。在程序开发中会存在多线程同步的问题，当多个线程并发访问某个数据的时候，尤其是针对一些敏感的数据（比如订单、金额等），我们就需要保证这个数据在任何时刻最多只有一个线程在访问，保证数据的完整性和`一致性。在开发过程中加锁是为了保证数据的一致性，这个思想在数据...","head":[["meta",{"property":"og:url","content":"https://Ragnarokoo.github.io/LearningNotes/notes/db/mysql_pro/%E7%AC%AC15%E7%AB%A0_%E9%94%81.html"}],["meta",{"property":"og:site_name","content":"📚全栈开发学习指南"}],["meta",{"property":"og:title","content":"第 15 章_锁"}],["meta",{"property":"og:description","content":"事务的隔离性由这章讲述的锁来实现。 1. 概述 锁是计算机协调多个进程或线程并发访问某一资源的机制。在程序开发中会存在多线程同步的问题，当多个线程并发访问某个数据的时候，尤其是针对一些敏感的数据（比如订单、金额等），我们就需要保证这个数据在任何时刻最多只有一个线程在访问，保证数据的完整性和`一致性。在开发过程中加锁是为了保证数据的一致性，这个思想在数据..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://Ragnarokoo.github.io/LearningNotes/"}],["meta",{"property":"og:updated_time","content":"2023-05-31T09:16:41.000Z"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"第 15 章_锁"}],["meta",{"property":"article:tag","content":"mysql"}],["meta",{"property":"article:tag","content":"SQL"}],["meta",{"property":"article:tag","content":"关系型数据库"}],["meta",{"property":"article:modified_time","content":"2023-05-31T09:16:41.000Z"}]]},"excerpt":"","headers":[{"level":2,"title":"1. 概述","slug":"_1-概述","link":"#_1-概述","children":[]},{"level":2,"title":"2. MySQL并发事务访问相同记录","slug":"_2-mysql并发事务访问相同记录","link":"#_2-mysql并发事务访问相同记录","children":[{"level":3,"title":"2. 1 读-读情况","slug":"_2-1-读-读情况","link":"#_2-1-读-读情况","children":[]},{"level":3,"title":"2. 2 写-写情况","slug":"_2-2-写-写情况","link":"#_2-2-写-写情况","children":[]},{"level":3,"title":"2. 3 读-写或写-读情况","slug":"_2-3-读-写或写-读情况","link":"#_2-3-读-写或写-读情况","children":[]},{"level":3,"title":"2. 4 并发问题的解决方案","slug":"_2-4-并发问题的解决方案","link":"#_2-4-并发问题的解决方案","children":[]}]},{"level":2,"title":"3. 锁的不同角度分类","slug":"_3-锁的不同角度分类","link":"#_3-锁的不同角度分类","children":[{"level":3,"title":"3. 1 从数据操作的类型划分：读锁、写锁","slug":"_3-1-从数据操作的类型划分-读锁、写锁","link":"#_3-1-从数据操作的类型划分-读锁、写锁","children":[]},{"level":3,"title":"3.2 从数据操作的粒度划分：表级锁、页级锁、行锁","slug":"_3-2-从数据操作的粒度划分-表级锁、页级锁、行锁","link":"#_3-2-从数据操作的粒度划分-表级锁、页级锁、行锁","children":[]},{"level":3,"title":"3. 3 从对待锁的态度划分:乐观锁、悲观锁","slug":"_3-3-从对待锁的态度划分-乐观锁、悲观锁","link":"#_3-3-从对待锁的态度划分-乐观锁、悲观锁","children":[]},{"level":3,"title":"3. 4 按加锁的方式划分：显式锁、隐式锁","slug":"_3-4-按加锁的方式划分-显式锁、隐式锁","link":"#_3-4-按加锁的方式划分-显式锁、隐式锁","children":[]}]},{"level":2,"title":"即：一个事务对新插入的记录可以不显式的加锁（生成一个锁结构），但是由于事务id的存在，相当于加了一个隐式锁。别的事务在对这条记录加S锁或者X锁时，由于隐式锁的存在，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构后进入等待状态。隐式锁是一种延迟加锁的机制，从而来减少加锁的数量。","slug":"即-一个事务对新插入的记录可以不显式的加锁-生成一个锁结构-但是由于事务id的存在-相当于加了一个隐式锁。别的事务在对这条记录加s锁或者x锁时-由于隐式锁的存在-会先帮助当前事务生成一个锁结构-然后自己再生成一个锁结构后进入等待状态。隐式锁是一种延迟加锁的机制-从而来减少加锁的数量。","link":"#即-一个事务对新插入的记录可以不显式的加锁-生成一个锁结构-但是由于事务id的存在-相当于加了一个隐式锁。别的事务在对这条记录加s锁或者x锁时-由于隐式锁的存在-会先帮助当前事务生成一个锁结构-然后自己再生成一个锁结构后进入等待状态。隐式锁是一种延迟加锁的机制-从而来减少加锁的数量。","children":[{"level":3,"title":"3. 5 其它锁之：全局锁","slug":"_3-5-其它锁之-全局锁","link":"#_3-5-其它锁之-全局锁","children":[]},{"level":3,"title":"3. 6 其它锁之：死锁","slug":"_3-6-其它锁之-死锁","link":"#_3-6-其它锁之-死锁","children":[]}]},{"level":2,"title":"4. 锁的内存结构","slug":"_4-锁的内存结构","link":"#_4-锁的内存结构","children":[]},{"level":2,"title":"5. 锁监控","slug":"_5-锁监控","link":"#_5-锁监控","children":[]},{"level":2,"title":"6. 附录","slug":"_6-附录","link":"#_6-附录","children":[]}],"git":{"createdTime":1685524601000,"updatedTime":1685524601000,"contributors":[{"name":"kirito","email":"2724964601@qq.com","commits":1}]},"readingTime":{"minutes":81.97,"words":24590},"filePathRelative":"notes/db/mysql_pro/第15章_锁.md","localizedDate":"2023年5月31日"}');export{e as data};
