import{_ as e}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as i,c as p,a}from"./app.9b10ba0a.js";const s="/assets/3c592f729db04016a1d24513e68a3609~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.a2406d8d.png",d="/assets/8f1d51b8e3f348c78a7a7975c1fe85e2~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.5af3fce0.jpeg",l="/assets/d055249fde164f4db15f0c50a3c19a24~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.39584588.jpeg",r="/assets/90b11176c83b4e9db53d8d9e7d37c081~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.add2866e.jpeg",t="/assets/f9ea7da2d47a41d7b99600241fe2d3b5~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.d2bea5f4.jpeg",o="/assets/f49ace60f7474173b6c29b5cec9fd51a~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.7e81310a.jpeg",c="/assets/d95e6b7e228e490daea7125cdb928479~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.9411fafd.jpeg",n="/assets/6009084bf1d842fe94a82720f1f6c6c0~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.38991753.jpeg",h="/assets/59a7dba7069446faa6fe6cd3094ca9e5~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.59237cae.jpeg",_="/assets/e5f3ae77470f4872af3b736e1c703fc5~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.8f6281a9.jpeg",m="/assets/89c64c2d54ea4d18bad6f93b9d4022cc~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.1c0d44ad.jpeg",f="/assets/a46f241591294e4c98cf964b7b39495a~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.e14d4b60.jpeg",g="/assets/cb34613d39e5460ab89aaf38d7391ec6~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.065224f6.jpeg",b="/assets/1f229d88c3bd4af49c198ad505c426d6~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.535a13da.jpeg",u="/assets/021e61b6baef4659995b923b931ae804~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.297bd319.jpeg",R="/assets/ec6e445541854e28b167783c9323e07a~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.7fc74a5d.jpeg",k={},v=a('<h2 id="一、同样是缓存-用map不行吗" tabindex="-1"><a class="header-anchor" href="#一、同样是缓存-用map不行吗" aria-hidden="true">#</a> 一、同样是缓存，用map不行吗？</h2><ol><li>Redis可以存储几十个G的数据，Map行吗？</li><li>Redis的缓存可以进行本地持久化，Map行吗？</li><li>Redis可以作为分布式缓存，Map只能在同一个JVM中进行缓存；</li><li>Redis支持每秒百万级的并发，Map行吗？</li><li>Redis有过期机制，Map有吗？</li><li>Redis有丰富的API，支持非常多的应用场景，Map行吗？</li></ol><p><img src="'+s+'" alt="img"></p><h2 id="二、redis为什么是单线程的" tabindex="-1"><a class="header-anchor" href="#二、redis为什么是单线程的" aria-hidden="true">#</a> 二、Redis为什么是单线程的？</h2><ol><li>代码更清晰，处理逻辑更简单；</li><li>不用考虑各种锁的问题，不存在加锁和释放锁的操作，没有因为可能出现死锁而导致的性能问题；</li><li>不存在多线程切换而消耗CPU；</li><li>无法发挥多核CPU的优势，但可以采用多开几个Redis实例来完善；</li></ol><h2 id="三、redis真的是单线程的吗" tabindex="-1"><a class="header-anchor" href="#三、redis真的是单线程的吗" aria-hidden="true">#</a> 三、Redis真的是单线程的吗？</h2><ol><li>Redis6.0之前是单线程的，Redis6.0之后开始支持多线程；</li><li>Redis内部使用了基于epoll的多路服用，也可以多部署几个Redis服务器解决单线程的问题；</li><li>Redis主要的性能瓶颈是内存和网络；</li><li>内存好说，加内存条就行了，而网络才是大麻烦，所以Redis6内存好说，加内存条就行了；</li><li>而网络才是大麻烦，所以Redis6.0引入了多线程的概念，</li><li>Redis6.0在网络IO处理方面引入了多线程，如网络数据的读写和协议解析等，需要注意的是，执行命令的核心模块还是单线程的。</li></ol><h2 id="四、redis优缺点" tabindex="-1"><a class="header-anchor" href="#四、redis优缺点" aria-hidden="true">#</a> 四、Redis优缺点</h2><h3 id="_1、优点" tabindex="-1"><a class="header-anchor" href="#_1、优点" aria-hidden="true">#</a> 1、优点</h3><ol><li>Redis是KV数据库，MySQL是关系型数据库，Redis速度更快；</li><li>Redis数据操作主要在内存中，MySQL主要将数据存储在硬盘，Redis速度更快；</li><li>Redis同样支持持久化（RDB+AOF），Redis支持将数据异步将内存的数据持久化到硬盘上，避免Redis宕机出现数据丢失的问题；</li><li>Redis性能极高，读的速度是110000次/秒，写的速度是81000次/秒；</li><li>Redis数据类型丰富，不仅支持KV键值对，还支持list、set、zset、hash等数据结构的存储；</li><li>Redis支持数据的备份，即master-slave模式的数据备份；</li><li>Redis支持简单的事务，操作满足原子性；</li><li>Redis支持读写分离，分担读的压力；</li><li>Redis支持哨兵模式，实现故障的自动转移；</li><li>单线程操作，避免了频繁的上下文切换；</li><li>采用了非阻塞I/O多路复用机制，性能卓越；</li></ol><h3 id="_2、缺点" tabindex="-1"><a class="header-anchor" href="#_2、缺点" aria-hidden="true">#</a> 2、缺点</h3><ol><li>数据存储在内存，容易造成数据丢失；</li><li>存储容量受内存的限制，只能存储少量的常用数据；</li><li>缓存和数据库双写一致性问题；</li><li>用于缓存时，容易出现内存穿透、缓存击穿、缓存雪崩的问题；</li><li>修改配置文件后，需要进行重启，将硬盘中的数据同步到内存中，消耗的时间较长，而且数据同步的时间里Redis不能提供服务；</li></ol><h2 id="五、redis常见业务场景" tabindex="-1"><a class="header-anchor" href="#五、redis常见业务场景" aria-hidden="true">#</a> 五、Redis常见业务场景</h2><ol><li>Redis是基于内存的nosql数据库，可以通过新建线程的形式进行持久化，不影响Redis单线程的读写操作</li><li>通过list取最新的N条数据</li><li>模拟类似于token这种需要设置过期时间的场景</li><li>发布订阅消息系统</li><li>定时器、计数器</li><li>缓存加速、分布式会话、排行榜、分布式计数器、分布式锁；</li><li>Redis支持事务、持久化、LUA脚本、发布/订阅、缓存淘汰、流技术等特性；</li></ol><h2 id="六、redis常见数据类型" tabindex="-1"><a class="header-anchor" href="#六、redis常见数据类型" aria-hidden="true">#</a> 六、Redis常见数据类型</h2><p><img src="'+d+'" alt="img"></p><h3 id="_1、string" tabindex="-1"><a class="header-anchor" href="#_1、string" aria-hidden="true">#</a> 1、String</h3><p>（1）String简介</p><p>String 是最基本的 key-value 结构，key 是唯一标识，value 是具体的值，value其实不仅是字符串， 也可以是数字（整数或浮点数），value 最多可以容纳的数据长度是 512M。</p><p>（2）应用场景</p><p>① 作为缓存数据库</p><p>在Java管理系统体系中，大多数都是用MySQL存储数据，redis作为缓存，因为Redis具有支撑高并发的特性，通常能起到加速读写和降低数据库服务器压力的作用，大多数请求都会先请求Redis，如果Redis中没有数据，再请求MySQL数据库，然后再缓存到Redis中，以备下次使用。</p><p><img src="'+l+'" alt="img"></p><p>② 计数器</p><p>Redis字符串中有一个命令<code>INCR key</code>，incr命令会对值进行自增操作，比如CSDN的文章阅读，视频的播放量，都可以通过Redis来计数，每阅读一次就+1，同时将这些数据异步存储到MySQL数据库中，降低MySQL服务器的写入压力。</p><p>③ 共享session</p><p>在分布式系统中，用户每次请求一般会访问不同的服务器 ，这就会导致session不同步的问题，这时，一般会使用Redis来解决这个问题，将session存入Redis，使用的时候从Redis中取出就可以了。</p><p>④ 分布式锁</p><ol><li>setnx key value，加锁</li><li>del key，释放锁</li></ol><p>（3）key操作命令</p><p><img src="'+r+`" alt="img"></p><p>（4）set key value</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>SET key value [NX | XX] [GET] [EX seconds | PX milliseconds |  EXAT unix-time-seconds | PXAT unix-time-milliseconds | KEEPTTL]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol><li>EX seconds，设置过期时间，单位秒</li><li>PX milliseconds，设置过期时间，单位毫秒</li><li>EXAT timestamp-seconds，设置过期时间，以秒为单位的UNIX时间戳</li><li>PXAT timestamp-milliseconds，设置过期时间，以毫秒为单位的UNIX时间戳</li><li>NX，键不存在的时候设置键值</li><li>XX，键存在的时候设置键值</li><li>KEEPTTL，保留设置前指定键的生存时间</li><li>GET，返回指定键原本的值，若键不存在返回nil</li></ol><p>备注：</p><p>命令不区分大小写，而key是区分大小写的。</p><p><code>help @类型</code>：查看当前类型相关的操作命令。</p><p>Since the SET command options can replace SETNX, SETEX, PSETEX, GETSET, it is possible that in future versions of Redis these commands will be deprecated and finally removed。</p><p>（5）同时设置多个键值</p><p>（6）获取指定区间范围内的值</p><p>getrange、setrange。</p><p>（7）数值增减</p><ol><li>INCR key，递增数字</li><li>INCRBY key increment，增加指定的数值递增</li><li>DECR key，递减数值</li><li>DECRBY key decrement，指定指定的数值递减</li></ol><p>（8）获取字符串的长度，内容追加</p><ol><li>STRLEN key，获取值的长度</li><li>APPEND key value，内容追加</li></ol><h3 id="_2、list" tabindex="-1"><a class="header-anchor" href="#_2、list" aria-hidden="true">#</a> 2、List</h3><p>（1）List 列表简介</p><p>List 列表是简单的字符串列表，按照插入顺序排序，可以从头部或尾部向 List 列表添加元素。</p><p>列表的最大长度为 2^32 - 1，也即每个列表支持超过 40 亿个元素。</p><p>主要功能有push/pop，一般用在栈、队列、消息队列等场景。</p><ol><li>left、right都可以插入添加；</li><li>如果键不存在，创建新的链表；</li><li>如果键存在，新增内容；</li><li>如果值全部移除，对应的键也会消失；</li></ol><p>它的底层是<strong>双向链表，对两端的操作性能很高</strong>，通过索引下标操作中间的节点，性能会较差。</p><p>（2）应用场景</p><p>① 消息队列</p><p>使用 <code>lpush + rpop</code>或者 <code>rpush + lpop</code>实现消息队列，Redis还支持阻塞操作，在弹出元素的时候使用阻塞命令来实现阻塞队列。</p><p><img src="`+t+'" alt="img"></p><p>② 作为栈使用</p><p>使用 <code>lpush+lpop</code>或者 <code>rpush+rpop</code>实现栈。</p><p><img src="'+o+'" alt="img"></p><p>③ 文章列表</p><p>（3）常用命令</p><p><img src="'+c+'" alt="img"></p><h3 id="_3、hash" tabindex="-1"><a class="header-anchor" href="#_3、hash" aria-hidden="true">#</a> 3、Hash</h3><p>（1）hash简介</p><p>Hash 是一个键值对（key - value）集合，value也是一个hash，相当于 <code>Map&lt;String,Map&lt;Object,Object&gt;&gt;</code>。</p><p>（2）常用场景</p><p>由于特殊的数据结构，hash一般作为存储bean使用，String+JSON的数据结构存储特定的应用场景。</p><p><img src="'+n+'" alt="img"></p><p>（3）常用命令</p><p><img src="'+h+'" alt="img"></p><p><img src="'+_+'" alt="img"></p><h3 id="_4、set" tabindex="-1"><a class="header-anchor" href="#_4、set" aria-hidden="true">#</a> 4、Set</h3><p>（1）Set类型简介</p><p>Set 类型是一个无序并唯一的键值集合，它的存储顺序不会按照插入的先后顺序进行存储。</p><p>一个集合最多可以存储 2^32-1 个元素。概念和数学中个的集合基本类似，可以交集，并集，差集等等，所以 Set 类型除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集。</p><p>（2）应用场景</p><p>① 相同好友可见</p><p>在朋友圈场景中，对于点赞、评论的功能，通过交集实现相同还有可见的功能。</p><p>② 共同关注、共同喜好</p><p>③ 抽奖功能</p><p>（3）常用命令</p><p><img src="'+m+`" alt="img"></p><h3 id="_5、zset" tabindex="-1"><a class="header-anchor" href="#_5、zset" aria-hidden="true">#</a> 5、Zset</h3><p>（1）Zset 类型简介</p><p>Zset 类型（有序集合类型）相比于 Set 类型多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序结合的元素值，一个是排序值。</p><p>有序集合保留了集合不能有重复成员的特性（分值可以重复），但不同的是，有序集合中的元素可以排序。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>zset k1 score1 v1 score2 v2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>（2）应用场景</p><p>① 排行榜</p><p>通过score来记录点赞数，然后根据score进行排序，实现排行榜的功能。</p><p>② 延迟消息队列</p><p>订单系统，下单后需要在15分钟内进行支付操作，否则自动取消订单。</p><p>将下单后15分钟后的时间作为score，订单作为value存入Redis，消费者轮询去消费，如果消费的大于等于score，则取消该订单。</p><p>（3）Zset常用命令</p><p><img src="`+f+'" alt="img"></p><h3 id="_6、bitmap" tabindex="-1"><a class="header-anchor" href="#_6、bitmap" aria-hidden="true">#</a> 6、BitMap</h3><p>（1）Bitmap简介</p><p>Bitmap，即位图，是一串连续的二进制数组（0和1），可以通过偏移量（offset）定位元素。BitMap通过最小的单位bit来进行0|1的设置，表示某个元素的值或者状态，时间复杂度为O(1)。</p><p>（2）应用场景</p><p>由于 bit 是计算机中最小的单位，使用它进行储存将非常节省空间，特别适合一些数据量大且使用二值统计的场景。</p><p>① 签到统计</p><p>② 判断用户是否登录</p><p>③ 统计连续学习打卡的人</p><p>（3）BitMap常用命令</p><p><img src="'+g+'" alt="img"></p><h3 id="_7、bitfield" tabindex="-1"><a class="header-anchor" href="#_7、bitfield" aria-hidden="true">#</a> 7、BitField</h3><p>通过bitfield命令可以一次性操作多个比特位，它会执行一系列操作并返回一个响应数组，这个数组中的元素对参数列表中的相应操作的执行结果。</p><h3 id="_8、hyperloglog" tabindex="-1"><a class="header-anchor" href="#_8、hyperloglog" aria-hidden="true">#</a> 8、HyperLogLog</h3><p>（1）HyperLogLog简介</p><p>Redis HyperLogLog 是 Redis 2.8.9 版本新增的数据类型，是一种用于「<strong>统计基数</strong>」的数据集合类型，基数统计就是指统计一个集合中不重复的元素个数。但要注意，HyperLogLog 是统计规则是基于概率完成的，不是非常准确，标准误算率是 0.81%。</p><p>所以，简单来说 HyperLogLog 提供不精确的去重计数。</p><p>HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的内存空间总是固定的、并且是很小的。</p><p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数，和元素越多就越耗费内存的 Set 和 Hash 类型相比，HyperLogLog 就非常节省空间。</p><p>（2）应用场景</p><p>百万级网页 UV 计数</p><p>（3）常用命令</p><ol><li>pfadd key element，添加元素</li><li>pfcount key，返回指定HyperLogLog的基数的估算值；</li><li>pfmerge destkey sourcekey，将多个HyperLogLog合并成一个HyperLogLog；</li></ol><h3 id="_9、geo" tabindex="-1"><a class="header-anchor" href="#_9、geo" aria-hidden="true">#</a> 9、GEO</h3><p>（1）GEO简介</p><p>Redis GEO 是 Redis 3.2 版本新增的数据类型，主要用于存储地理位置信息，并对存储的信息进行操作。</p><p>在日常生活中，我们越来越依赖搜索“附近的餐馆”、在打车软件上叫车，这些都离不开基于位置信息服务（Location-Based Service，LBS）的应用。LBS 应用访问的数据是和人或物关联的一组经纬度信息，而且要能查询相邻的经纬度范围，GEO 就非常适合应用在 LBS 服务的场景中。</p><p>（2）应用场景</p><p>高德地图、滴滴打车等定位软件。</p><p>（3）常用命令</p><p><img src="'+b+'" alt="img"></p><h3 id="_10、stream" tabindex="-1"><a class="header-anchor" href="#_10、stream" aria-hidden="true">#</a> 10、Stream</h3><p>（1）Stream简介</p><p>Redis Stream 是 Redis 5.0 版本新增加的数据类型，Redis 专门为消息队列设计的数据类型。</p><p><img src="'+u+'" alt="img"></p><p>在 Redis 5.0 Stream 没出来之前，消息队列的实现方式都有着各自的缺陷，例如：</p><ul><li>发布订阅模式，不能持久化也就无法可靠的保存消息，并且对于离线重连的客户端不能读取历史消息的缺陷；</li><li>List 实现消息队列的方式不能重复消费，一个消息消费完就会被删除，而且生产者需要自行实现全局唯一 ID。</li></ul><p>基于以上问题，Redis 5.0 便推出了 Stream 类型也是此版本最重要的功能，用于完美地实现消息队列，它支持消息的持久化、支持自动生成全局唯一 ID、支持 ack 确认消息的模式、支持消费组模式等，让消息队列更加的稳定和可靠。</p><p>（2）应用场景</p><p>消息队列</p><p>（3）常用命令</p><p><img src="'+R+'" alt="img"></p><h3 id="七、总结" tabindex="-1"><a class="header-anchor" href="#七、总结" aria-hidden="true">#</a> 七、总结</h3><p>Redis是一个key-value存储系统，支持10种数据类型，总结了为何要用Redis替代map作为程序缓存、Redis为什么是单线程的、Redis的优缺点、Redis的常用场景，做了一次Redis的快速入门。</p>',138),y=[v];function L(S,x){return i(),p("div",null,y)}const z=e(k,[["render",L],["__file","既然有Map了，为什么还要有Redis？.html.vue"]]);export{z as default};
