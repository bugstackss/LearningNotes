import{_ as l}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as t,c,d as e,e as s,b as a,a as i,r as o}from"./app.9b10ba0a.js";const r="/assets/image-20230520182259235.01bb2f46.png",p="/assets/image-20230520182951138.9fa604a1.png",d="/assets/image-20230520202459433.9d1468a3.png",u="/assets/image-20230520202545376.30e8aab0.png",m="/assets/image-20230520203634535.c964796e.png",b="/assets/image-20230520203700831.662085fa.png",v="/assets/image-20230520204141077.991f32e1.png",g="/assets/image-20230520204159867.3fd7bb95.png",k="/assets/image-20230520204216175.6a23789c.png",h="/assets/image-20230520204254348.6c66fabf.png",_="/assets/image-20230520204531567.cb34cff6.png",f="/assets/image-20230520204656790.a37b5eed.png",D="/assets/image-20230520204836223.e75d8bd7.png",N="/assets/image-20230520204847523.6a834e07.png",E="/assets/image-20230520205022585.49681117.png",R="/assets/image-20230520205107970.fe3bfdd6.png",M="/assets/image-20230520205327808.c3504590.png",T="/assets/image-20230520205419648.cd866b76.png",x="/assets/image-20230520205505943.268a546e.png",A="/assets/image-20230520205716437.787b1320.png",O="/assets/image-20230520204340102.5e12e80d.png",y={},P=e("h2",{id:"一、是什么",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#一、是什么","aria-hidden":"true"},"#"),s(" 一、是什么")],-1),q=e("p",null,"DockerFile是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。",-1),C=e("p",null,[e("strong",null,"概述")],-1),H=e("p",null,[e("img",{src:r,alt:"image-20230520182259235"})],-1),j={href:"https://docs.docker.com/engine/reference/builder/",target:"_blank",rel:"noopener noreferrer"},U=i('<p><strong>构建三步骤</strong></p><ol><li>编写Dockerfile文件</li><li>docker builde命令构建镜像</li><li>docker run依镜像运行容器示例</li></ol><h2 id="二、dockerfile构建过程解析" tabindex="-1"><a class="header-anchor" href="#二、dockerfile构建过程解析" aria-hidden="true">#</a> 二、DockerFile构建过程解析</h2><blockquote><p>Docker内容基础知识</p></blockquote><p>1：每条保留字指令都<code>必须为大写字母</code>且后面要跟随最少一个参数</p><p>2：指令按照从上到下，顺序执行</p><p>3：#表示注释</p><p>4：每条指令都会创建一个新的镜像层并对镜像进行提交</p><blockquote><p>Docker执行的Dockerfile的大致流程</p></blockquote><p>（1）docker从基础镜像运行一个容器</p><p>（2）执行一条指令并对容器作出修改</p><p>（3）执行类似docker commit的操作提交一个新的镜像层</p><p>（4）docker 再基于刚提交的镜像运行一个新容器</p><p>（5）执行dockerfile中的下一条指令直到所有指令都执行完成</p><blockquote><p>小总结</p></blockquote><p>从应用软件的角度来看，Dockerfile、Docker镜像与Docker容器分别代表软件的三个不同阶段，</p><ul><li><p>Dockerfile是软件的原材料</p></li><li><p>Docker镜像是软件的交付品</p></li><li><p>Docker容器则可以认为是软件镜像的运行态，也即依照镜像运行的容器实例</p></li></ul><p>Dockerfile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可，合力充当Docker体系的基石。</p><p><img src="'+p+'" alt="image-20230520182951138"></p><p>1 Dockerfile，需要定义一个Dockerfile，Dockerfile定义了进程需要的一切东西。Dockerfile涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制)等等;</p><p>2 Docker镜像，在用Dockerfile定义一个文件之后，docker build时会产生一个Docker镜像，当运行 Docker镜像时会真正开始提供服务;</p><p>3 Docker容器，容器是直接提供服务的。</p><h2 id="三、dockerfile常用保留字指令" tabindex="-1"><a class="header-anchor" href="#三、dockerfile常用保留字指令" aria-hidden="true">#</a> 三、DockerFile常用保留字指令</h2>',23),I={href:"https://github.com/docker-library/tomcat",target:"_blank",rel:"noopener noreferrer"},Y=i('<ul><li>FROM</li></ul><p>基础镜像，当前镜像是基于哪个镜像的，指定一个已经存在的镜像作为模版，第一条必须是from</p><ul><li>MAINTAINER</li></ul><p>镜像维护者的姓名和邮箱地址</p><ul><li>RUN</li></ul><p>容器构建时需要运行的命令</p><blockquote><p>两种格式：</p><ul><li>shell格式</li></ul><p><img src="'+d+`" alt="image-20230520202459433"></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>RUN yum <span class="token parameter variable">-y</span> <span class="token function">install</span> <span class="token function">vim</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>exec格式</li></ul><p><img src="`+u+'" alt="image-20230520202545376"></p></blockquote><p>RUN是在docker build时运行</p><ul><li>EXPOSE</li></ul><p>当前容器对外暴漏出的端口</p><ul><li>WORKDIR</li></ul><p>指定在创建容器后，终端默认登录的进来工作目录，一个落脚点</p><ul><li>USER</li></ul><p>指定该镜像以什么样的用户去执行，如果不指定，默认是root</p><ul><li>ENV</li></ul><p>用来构建镜像过程中设置环境变量</p><p>ENV MY_PATH /usr/mytest</p><p>这个环境变量可以在后续的任何RUN指令中使用，这就如同在命令前面指定了环境变量前缀一样；</p><p>也可以在其它指令中直接使用这些环境变量，比如：WORKDIR $MY_PATH</p><ul><li>ADD</li></ul><p>将宿主机目录下的文件拷贝进镜像且会自动处理URL和解压tar压缩包</p><ul><li>COPY</li></ul><p>类似ADD，拷贝文件和目录到镜像中。</p><p>将从构建上下文目录中，&lt; 源路径 &gt;的文件/目录复制到新的一层的镜像内的&lt; 目标路径 &gt;位置</p><blockquote><ul><li>COPY src dest</li><li>COPY [“src”,”dest”]</li><li>&lt; src源路径 &gt;：源文件或者源目录</li><li>&lt; dest目标路径 &gt;：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建</li></ul></blockquote><ul><li>VOLUME</li></ul><p>容器数据卷，用于数据保存和持久化工作</p><ul><li>CMD</li></ul><p>指定容器启动时要干的事情</p><blockquote><p>注意：</p><p>DockerFile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换</p><p>参考官网Tomcat的dockerfile演示案例</p><p>官网最后一行命令</p><p><img src="'+m+'" alt="image-20230520203634535"></p><p>我们演示自己的覆盖操作</p><p><img src="'+b+'" alt="image-20230520203700831"></p><p>它和前面RUN命令的区别</p><ul><li>CMD是在docker run时运行。</li><li>RUN是在docker build时运行。</li></ul></blockquote><ul><li>ENTRYPOINT</li></ul><p>也是用来指定一个容器启动时要运行的命令</p><p>类似于CMD指令，<code>但是ENTRYPOINT不会被docker run后面的命令覆盖，而且这些命令行参数会被当做参数送给ENTRYPOINT指令指定的程序</code></p><p>命令格式和案例说明</p><p>命令格式：</p><p><img src="'+v+'" alt="image-20230520204141077"></p><p>ENTRYPOINT可以和CMD一起用，一般是变参才会使用 CMD ，这里的 CMD 等于是在给 ENTRYPOINT 传参。</p><p>当指定了ENTRYPOINT后，CMD的含义就发生了变化，不再是直接运行其命令而是将CMD的内容作为参数传递给ENTRYPOINT指令，他两个组合会变成</p><p><img src="'+g+'" alt="image-20230520204159867"></p><p>案例如下：假设已通过 Dockerfile 构建了 nginx:test 镜像：</p><p><img src="'+k+'" alt="image-20230520204216175"></p><table><thead><tr><th>是否传参</th><th>按照dockerfile编写执行</th><th>传参运行</th></tr></thead><tbody><tr><td>Docker命令</td><td>docker run nginx:test</td><td>docker run nginx:test -c /etc/nginx/new.conf</td></tr><tr><td>衍生出的实际命令</td><td>nginx -c /etc/nginx/nginx.conf</td><td>nginx -c /etc/nginx/new.conf</td></tr></tbody></table><blockquote><p>优点：在执行docker run的时候可以指定 ENTRYPOINT运行所需要的参数。</p><p>注意：如果dockerfile中如果存在多个ENTRYPOINT指令，仅最后一个生效。</p></blockquote><ul><li>小总结</li></ul><p><img src="'+h+'" alt="image-20230520204254348"></p><h2 id="四、案例" tabindex="-1"><a class="header-anchor" href="#四、案例" aria-hidden="true">#</a> 四、案例</h2><h3 id="自定义镜像mycentosjava8" tabindex="-1"><a class="header-anchor" href="#自定义镜像mycentosjava8" aria-hidden="true">#</a> 自定义镜像mycentosjava8</h3><p>1.要求</p><p>CentOS7镜像具备vim+ifconfig+jdk8</p><p><strong>JDK的下载地址</strong></p>',50),L={href:"https://www.oracle.com/java/technologies/downloads/#java8",target:"_blank",rel:"noopener noreferrer"},S=e("p",null,[e("img",{src:_,alt:"image-20230520204531567"})],-1),V={href:"https://mirrors.yangxingzhen.com/jdk",target:"_blank",rel:"noopener noreferrer"},F=i('<p>2.编写</p><p>准备编写Dockerfile文件（大写字母D）</p><p><img src="'+f+`" alt="image-20230520204656790"></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 指定centos版本 centos:7</span>
FROM centos:7
<span class="token comment"># FROM centos</span>
MAINTAINER zzyy<span class="token operator">&lt;</span>zzyybs@126.com<span class="token operator">&gt;</span>
 
ENV MYPATH /usr/local
WORKDIR <span class="token variable">$MYPATH</span>
 
<span class="token comment">#安装vim编辑器</span>
RUN yum <span class="token parameter variable">-y</span> <span class="token function">install</span> <span class="token function">vim</span>
<span class="token comment">#安装ifconfig命令查看网络IP</span>
RUN yum <span class="token parameter variable">-y</span> <span class="token function">install</span> net-tools
<span class="token comment">#安装java8及lib库</span>
RUN yum <span class="token parameter variable">-y</span> <span class="token function">install</span> glibc.i686
RUN <span class="token function">mkdir</span> /usr/local/java
<span class="token comment">#ADD 是相对路径jar,把jdk-8u171-linux-x64.tar.gz添加到容器中,安装包必须要和Dockerfile文件在同一位置</span>
ADD jdk-8u171-linux-x64.tar.gz /usr/local/java/
<span class="token comment">#配置java环境变量</span>
ENV JAVA_HOME /usr/local/java/jdk1.8.0_171
ENV JRE_HOME <span class="token variable">$JAVA_HOME</span>/jre
ENV CLASSPATH <span class="token variable">$JAVA_HOME</span>/lib/dt.jar:<span class="token variable">$JAVA_HOME</span>/lib/tools.jar:<span class="token variable">$JRE_HOME</span>/lib:<span class="token variable">$CLASSPATH</span>
ENV <span class="token environment constant">PATH</span> <span class="token variable">$JAVA_HOME</span>/bin:<span class="token environment constant">$PATH</span>
 
EXPOSE <span class="token number">80</span>
 
CMD <span class="token builtin class-name">echo</span> <span class="token variable">$MYPATH</span>
CMD <span class="token builtin class-name">echo</span> <span class="token string">&quot;success--------------ok&quot;</span>
CMD /bin/bash
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3.构建</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> build <span class="token parameter variable">-t</span> 新镜像名字:TAG

<span class="token function">docker</span> build <span class="token parameter variable">-t</span> centosjava8:1.5 <span class="token builtin class-name">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+D+'" alt="image-20230520204836223"></p><p><img src="'+N+'" alt="image-20230520204847523"></p>',8),$=e("p",null,"注意，上面TAG后米娜有个空格，有个点",-1),z=e("p",null,[e("strong",null,"注意点"),s("：注意一下，这边阳哥的centos是7版本的，现在的最新版已经改为8版本了，pull拉取镜像的时候记得标明centos:7，不然8版本无论怎么改都是没办法下载的，FROM参数也要改成centos:7")],-1),w=e("p",null,"FROM centos:7 无用的话加一个参数 docker build --network host -t centosjava8:1.5 .",-1),J=e("p",null,"如果改成：7还不行，是网络问题的话就restart docker",-1),G={href:"https://www.jianshu.com/p/ebd80c7402ea",target:"_blank",rel:"noopener noreferrer"},K=i(`<p>4.运行</p><div class="language-SHELL line-numbers-mode" data-ext="SHELL"><pre class="language-SHELL"><code>docker run -it 新镜像名字:TAG

docker run -it centosjava8:1.5 /bin/bash
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+E+'" alt="image-20230520205022585"></p><p>5.再体会下UnionFS（联合文件系统）</p><p>UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持<strong>对文件系统的修改作为一次提交来一层层的叠加</strong>，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。<code>镜像可以通过分层来进行继承</code>，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p><p><img src="'+R+`" alt="image-20230520205107970"></p><p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p><h3 id="虚悬镜像" tabindex="-1"><a class="header-anchor" href="#虚悬镜像" aria-hidden="true">#</a> 虚悬镜像</h3><blockquote><p>是什么</p></blockquote><p>仓库名、标签都是&lt; none &gt;的镜像，俗称dangling image</p><p>Dockerfile写一个</p><p>1 vim Dockerfile</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>from ubuntu
CMD <span class="token builtin class-name">echo</span> <span class="token string">&#39;action is success&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>2 docker build .</p><p><img src="`+M+`" alt="image-20230520205327808"></p><blockquote><p>查看</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> image <span class="token function">ls</span> <span class="token parameter variable">-f</span> <span class="token assign-left variable">dangling</span><span class="token operator">=</span>true
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令结果</p><p><img src="`+T+`" alt="image-20230520205419648"></p><blockquote><p>删除</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> image purne
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>虚悬镜像已经失去存在价值，可以删除</p><p><img src="`+x+'" alt="image-20230520205505943"></p><h3 id="家庭作业–自定义镜像myubuntu" tabindex="-1"><a class="header-anchor" href="#家庭作业–自定义镜像myubuntu" aria-hidden="true">#</a> 家庭作业–自定义镜像myubuntu</h3><blockquote><p>编写编写Dockerfile文件</p><p><img src="'+A+`" alt="image-20230520205716437"></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>FROM ubuntu
MAINTAINER zzyy<span class="token operator">&lt;</span>zzyybs@126.com<span class="token operator">&gt;</span>
 
ENV MYPATH /usr/local
WORKDIR <span class="token variable">$MYPATH</span>
 
RUN <span class="token function">apt-get</span> update
RUN <span class="token function">apt-get</span> <span class="token function">install</span> net-tools
<span class="token comment">#RUN apt-get install -y iproute2</span>
<span class="token comment">#RUN apt-get install -y inetutils-ping</span>
 
EXPOSE <span class="token number">80</span>
 
CMD <span class="token builtin class-name">echo</span> <span class="token variable">$MYPATH</span>
CMD <span class="token builtin class-name">echo</span> <span class="token string">&quot;install inconfig cmd into ubuntu success--------------ok&quot;</span>
CMD /bin/bash
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> build <span class="token parameter variable">-t</span> 新镜像名字:TAG <span class="token builtin class-name">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-SHELL line-numbers-mode" data-ext="SHELL"><pre class="language-SHELL"><code>docker run -it 新镜像名字:TAG
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="五、小总结" tabindex="-1"><a class="header-anchor" href="#五、小总结" aria-hidden="true">#</a> 五、小总结</h2><p><img src="`+O+'" alt="image-20230520204340102"></p>',29);function W(B,X){const n=o("ExternalLinkIcon");return t(),c("div",null,[P,q,C,H,e("p",null,[e("strong",null,[e("a",j,[s("官网"),a(n)])])]),U,e("p",null,[e("a",I,[s("参考tomcat8的dockerfile入门"),a(n)])]),Y,e("p",null,[e("a",L,[s("官网"),a(n)])]),S,e("p",null,[e("a",V,[s("加速镜像网站"),a(n)])]),F,e("blockquote",null,[$,z,w,J,e("p",null,[s("参考文章："),e("a",G,[s("Dockerfile中 RUN yum -y install vim失败Cannot prepare internal mirrorlist: No URLs in mirrorlist - 简书 (jianshu.com)"),a(n)])])]),K])}const ee=l(y,[["render",W],["__file","2.DockerFile解析.html.vue"]]);export{ee as default};
