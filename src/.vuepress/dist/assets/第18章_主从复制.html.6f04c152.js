import{_ as e}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as a,c as s,a as i}from"./app.9b10ba0a.js";const n="/assets/image-20220329231136992.fc9e7644.png",l="/assets/image-20220329231214389.11749a67.png",d="/assets/image-20220329231300735.cd6a235b.png",r="/assets/image-20220329231429347.90aa9134.png",t="/assets/image-20220329231549800.ee1b891d.png",o="/assets/image-20220329232741694.998f82d7.png",p="/assets/image-20220329232934516.b58fa922.png",c="/assets/image-20220329232941780.b49c6628.png",m="data:image/png;base64,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",u="/assets/image-20220329232958011.ef939002.png",g="/assets/image-20220329233124775.048f06c2.png",v="/assets/image-20220329233204316.9556c672.png",b="/assets/image-20220329233352720.9fb38421.png",h="/assets/e74cdb04428b07731a11ab61f0e49e92.6231e03e.png",y="/assets/image-20220329233448778.5e28d051.png",E="/assets/image-20220329233714671.c09ad3c9.png",_="/assets/image-20220329233747296.cfd0dbf6.png",S="/assets/image-20220329233800680.9fbd05f5.png",A="/assets/image-20220329233847020.311ceeec.png",R="/assets/image-20220329234028528.3a8582e9.png",q="/assets/image-20220329234200370.ad06c5c8.png",T="/assets/image-20220329234212660.b7b283df.png",k="/assets/image-20220329234237134.35f75874.png",M={},x=i('<h1 id="第-18-章-主从复制" tabindex="-1"><a class="header-anchor" href="#第-18-章-主从复制" aria-hidden="true">#</a> 第 18 章_主从复制</h1><h2 id="_1-主从复制概述" tabindex="-1"><a class="header-anchor" href="#_1-主从复制概述" aria-hidden="true">#</a> 1. 主从复制概述</h2><h2 id="_1-1-如何提升数据库并发能力" tabindex="-1"><a class="header-anchor" href="#_1-1-如何提升数据库并发能力" aria-hidden="true">#</a> 1. 1 如何提升数据库并发能力</h2><p>在实际工作中，我们常常将<code>Redis</code>作为缓存与<code>MySQL</code>配合来使用，当有请求的时候，首先会从缓存中进行查找，如果存在就直接取出。如果不存在再访问数据库，这样就<code>提升了读取的效率</code>，也减少了对后端数据库的<code>访问压力</code>。Redis的缓存架构是<code>高并发架构</code>中非常重要的一环。</p><p><img src="'+n+'" alt="image-20220329231136992"></p><p>此外，一般应用对数据库而言都是“<code>读多写少</code>”，也就说对数据库读取数据的压力比较大，有一个思路就是采用数据库集群的方案，做<code>主从架构</code>、进行<code>读写分离</code>，这样同样可以提升数据库的并发处理能力。但并不是所有的应用都需要对数据库进行主从架构的设置，毕竟设置架构本身是有成本的。</p><p>如果我们的目的在于提升数据库高并发访问的效率，那么首先考虑的是如何优化<code>SQL和索引</code>，这种方式简单有效；其次才是采用<code>缓存的策略</code>，比如使用 Redis将热点数据保存在内存数据库中，提升读取的效率；最后才是对数据库采用<code>主从架构</code>，进行读写分离。</p><h2 id="_1-2-主从复制的作用" tabindex="-1"><a class="header-anchor" href="#_1-2-主从复制的作用" aria-hidden="true">#</a> 1. 2 主从复制的作用</h2><p>主从同步设计不仅可以提高数据库的吞吐量，还有以下 3 个方面的作用。</p><p>**第 1 个作用：读写分离。**我们可以通过主从复制的方式来同步数据，然后通过读写分离提高数据库并发处理能力</p><p><img src="'+l+'" alt="image-20220329231214389"></p><p>**第 2 个作用就是数据备份。**我们通过主从复制将主库上的数据复制到了从库上，相当于是一种热备份机制，也就是在主库正常运行的情况下进行的备份，不会影响到服务。</p><p>**第 3 个作用是具有高可用性。**数据备份实际上是一种冗余的机制，通过这种冗余的方式可以换取数据库的高可用性，也就是当服务器出现<code>故障</code>或<code>宕机</code>的情况下，可以<code>切换</code>到从服务器上，保证服务的正常运行。</p><p>关于高可用性的程度，我们可以用一个指标衡量，即正常可用时间/全年时间。比如要达到全年99.999%的时间都可用，就意味着系统在一年中的不可用时间不得超过<code>365*24*60*(1-99.999%)=5.256</code>分钟(含系统崩溃的时间、日常维护操作导致的停机时间等)，其他时间都需要保持可用的状态。</p><p>实际上，更高的高可用性，意味着需要付出更高的成本代价。在现实中我们需要结合业务需求和成本来进行选择。</p><h2 id="_2-主从复制的原理" tabindex="-1"><a class="header-anchor" href="#_2-主从复制的原理" aria-hidden="true">#</a> 2. 主从复制的原理</h2><p><code>Slave</code>会从<code>Master</code>读取<code>binlog</code>来进行数据同步。</p><h3 id="_2-1-原理剖析" tabindex="-1"><a class="header-anchor" href="#_2-1-原理剖析" aria-hidden="true">#</a> 2. 1 原理剖析</h3><h5 id="三个线程" tabindex="-1"><a class="header-anchor" href="#三个线程" aria-hidden="true">#</a> 三个线程</h5><p>实际上主从同步的原理就是基于 binlog 进行数据同步的。在主从复制过程中，会基于 <code>3 个线程</code>来操作，一个主库线程，两个从库线程。</p><p><img src="'+d+'" alt="image-20220329231300735"></p><p><code>二进制日志转储线程</code>（Binlog dump thread）是一个主库线程。当从库线程连接的时候， 主库可以将二进制日志发送给从库，当主库读取事件（Event）的时候，会在 Binlog 上<code>加锁</code>，读取完成之后，再将锁释放掉。</p><p><code>从库 I/O 线程会连接到主库</code>，向主库发送请求更新 Binlog。这时从库的 I/O 线程就可以读取到主库的二进制日志转储线程发送的 Binlog 更新部分，并且拷贝到本地的中继日志 （Relay log）。</p><p><code>从库 SQL 线程会</code>读取从库中的中继日志，并且执行日志中的事件，将从库中的数据与主库保持同步。</p><p><img src="'+r+'" alt="image-20220329231429347"></p><blockquote><p>注意: 不是所有版本的MySQL都默认开启服务器的二进制日志。在进行主从同步的时候，我们需要先检查服务器是否已经开启了二进制日志。</p><p>除非特殊指定，默认情况下从服务器会执行所有主服务器中保存的事件。也可以通过配置，使从服务器执行特定的事件。</p></blockquote><h5 id="复制三步骤" tabindex="-1"><a class="header-anchor" href="#复制三步骤" aria-hidden="true">#</a> 复制三步骤</h5><p>步骤 1 ：<code>Master</code>将写操作记录到二进制日志（<code>binlog</code>）。</p><p>步骤 2 ：<code>Slave</code>将<code>Master</code>的binary log events拷贝到它的中继日志（<code>relay log</code>）；</p><p>步骤 3 ：<code>Slave</code>重做中继日志中的事件，将改变应用到自己的数据库中。 MySQL复制是异步的且串行化 的，而且重启后从<code>接入点</code>开始复制。</p><p><strong>复制的问题</strong></p><p>复制的最大问题：<code>延时</code></p><h3 id="_2-2-复制的基本原则" tabindex="-1"><a class="header-anchor" href="#_2-2-复制的基本原则" aria-hidden="true">#</a> 2. 2 复制的基本原则</h3><ul><li>每个<code>Slave</code>只有一个<code>Master</code></li><li>每个<code>Slave</code>只能有一个唯一的服务器ID</li><li>每个<code>Master</code>可以有多个<code>Slave</code></li></ul><h2 id="_3-一主一从架构搭建" tabindex="-1"><a class="header-anchor" href="#_3-一主一从架构搭建" aria-hidden="true">#</a> 3. 一主一从架构搭建</h2><p>一台<code>主机</code>用于处理所有<code>写请求</code>，一台从机负责所有读请求，架构图如下：</p><p><img src="'+t+`" alt="image-20220329231549800"></p><h3 id="_3-1-准备工作" tabindex="-1"><a class="header-anchor" href="#_3-1-准备工作" aria-hidden="true">#</a> 3. 1 准备工作</h3><p>1 、准备 <code>2 台</code>CentOS 虚拟机</p><p>2 、每台虚拟机上需要安装好MySQL (可以是MySQL8.0 )</p><p>说明：前面我们讲过如何克隆一台CentOS。大家可以在一台CentOS上安装好MySQL，进而通过克隆的方式复制出 1 台包含MySQL的虚拟机。</p><p>注意：克隆的方式需要修改新克隆出来主机的：① <code>MAC地址</code> ② <code>hostname</code> ③ <code>IP 地址</code> ④ <code>UUID</code>。</p><p>此外，克隆的方式生成的虚拟机（包含MySQL Server），则克隆的虚拟机MySQL Server的UUID相同，必须修改，否则在有些场景会报错。比如：<code>show slave status\\G</code>，报如下的错误：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>Last_IO_Error: Fatal error: The slave I/O thread stops because master and slave have
equal MySQL server UUIDs<span class="token punctuation">;</span> these UUIDs must be different <span class="token keyword">for</span> replication to work.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>修改MySQL Server 的UUID方式：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">vim</span> /var/lib/mysql/auto.cnf
systemctl restart mysqld
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-2-主机配置文件" tabindex="-1"><a class="header-anchor" href="#_3-2-主机配置文件" aria-hidden="true">#</a> 3. 2 主机配置文件</h3><p>建议mysql版本一致且后台以服务运行，主从所有配置项都配置在[mysqld]节点下，且都是小写字母。</p><p>具体参数配置如下：</p><p><strong>必选</strong></p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token comment">#[必须]主服务器唯一ID</span>
<span class="token key attr-name">server-id</span><span class="token punctuation">=</span> <span class="token value attr-value">1</span>

<span class="token comment">#[必须]启用二进制日志,指名路径。比如：自己本地的路径/log/mysqlbin</span>
<span class="token key attr-name">log-bin</span><span class="token punctuation">=</span><span class="token value attr-value">atguigu-bin</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>可选</strong></p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token comment">#[可选] 0（默认）表示读写（主机）， 1 表示只读（从机）</span>
<span class="token key attr-name">read-only</span><span class="token punctuation">=</span> <span class="token value attr-value">0</span>

<span class="token comment">#设置日志文件保留的时长，单位是秒</span>
<span class="token key attr-name">binlog_expire_logs_seconds</span><span class="token punctuation">=</span> <span class="token value attr-value">6000</span>

<span class="token comment">#控制单个二进制日志大小。此参数的最大和默认值是1GB</span>
<span class="token key attr-name">max_binlog_size</span><span class="token punctuation">=</span><span class="token value attr-value">200M</span>

<span class="token comment">#[可选]设置不要复制的数据库</span>
<span class="token key attr-name">binlog-ignore-db</span><span class="token punctuation">=</span><span class="token value attr-value">test</span>

<span class="token comment">#[可选]设置需要复制的数据库,默认全部记录。比如：binlog-do-db=atguigu_master_slave</span>
<span class="token key attr-name">binlog-do-db</span><span class="token punctuation">=</span><span class="token value attr-value">需要复制的主数据库名字</span>

<span class="token comment">#[可选]设置binlog格式</span>
<span class="token key attr-name">binlog_format</span><span class="token punctuation">=</span><span class="token value attr-value">STATEMENT</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>binlog格式设置：</strong></p><p>格式 1 ：<code>STATEMENT模式</code>（基于SQL语句的复制(statement-based replication, SBR)）</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token key attr-name">binlog_format</span><span class="token punctuation">=</span><span class="token value attr-value">STATEMENT</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>每一条会修改数据的sql语句会记录到binlog中。这是默认的binlog格式。</p><ul><li>SBR 的优点： <ul><li>历史悠久，技术成熟</li><li>不需要记录每一行的变化，减少了binlog日志量，文件较小</li><li>binlog中包含了所有数据库更改信息，可以据此来审核数据库的安全等情况</li><li>binlog可以用于实时的还原，而不仅仅用于复制</li><li>主从版本可以不一样，从服务器版本可以比主服务器版本高</li></ul></li><li>SBR 的缺点： <ul><li>不是所有的UPDATE语句都能被复制，尤其是包含不确定操作的时候</li></ul></li><li>使用以下函数的语句也无法被复制：LOAD_FILE()、UUID()、USER()、FOUND_ROWS()、SYSDATE()(除非启动时启用了 --sysdate-is-now 选项) <ul><li>INSERT ... SELECT 会产生比 RBR 更多的行级锁</li><li>复制需要进行全表扫描(WHERE 语句中没有使用到索引)的 UPDATE 时，需要比 RBR 请求更多的行级锁</li><li>对于有 AUTO_INCREMENT 字段的 InnoDB表而言，INSERT 语句会阻塞其他 INSERT 语句</li><li>对于一些复杂的语句，在从服务器上的耗资源情况会更严重，而 RBR 模式下，只会对那个发生变化的记录产生影响</li><li>执行复杂语句如果出错的话，会消耗更多资源</li><li>数据表必须几乎和主服务器保持一致才行，否则可能会导致复制出错</li></ul></li></ul><p><strong>② ROW模式（基于行的复制(row-based replication, RBR)）</strong></p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token key attr-name">binlog_format</span><span class="token punctuation">=</span><span class="token value attr-value">ROW</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>5.1.5版本的MySQL才开始支持，不记录每条sql语句的上下文信息，仅记录哪条数据被修改了，修改成什么样了。</p><ul><li>RBR 的优点： <ul><li>任何情况都可以被复制，这对复制来说是最<code>安全可靠</code>的。（比如：不会出现某些特定情况下的存储过程、function、trigger的调用和触发无法被正确复制的问题）</li><li>多数情况下，从服务器上的表如果有主键的话，复制就会快了很多</li><li>复制以下几种语句时的行锁更少：INSERT ... SELECT、包含 AUTO_INCREMENT 字段的 INSERT、没有附带条件或者并没有修改很多记录的 UPDATE 或 DELETE 语句</li><li>执行 INSERT，UPDATE，DELETE 语句时锁更少</li><li>从服务器上采用<code>多线程</code>来执行复制成为可能</li></ul></li><li>RBR 的缺点： <ul><li>binlog 大了很多</li><li>复杂的回滚时 binlog 中会包含大量的数据</li><li>主服务器上执行 UPDATE 语句时，所有发生变化的记录都会写到 binlog 中，而 SBR 只会写一次，这会导致频繁发生 binlog 的并发写问题</li><li>无法从 binlog 中看到都复制了些什么语句</li></ul></li></ul><p><strong>③ MIXED模式（混合模式复制(mixed-based replication, MBR)）</strong></p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token key attr-name">binlog_format</span><span class="token punctuation">=</span><span class="token value attr-value">MIXED</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>从5.1.8版本开始，MySQL提供了Mixed格式，实际上就是Statement与Row的结合。</p><p>在Mixed模式下，一般的语句修改使用statment格式保存binlog。如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog。</p><p>MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种。</p><h3 id="_3-3-从机配置文件" tabindex="-1"><a class="header-anchor" href="#_3-3-从机配置文件" aria-hidden="true">#</a> 3. 3 从机配置文件</h3><p>要求主从所有配置项都配置在my.cnf的[mysqld]栏位下，且都是小写字母。</p><p><strong>必选</strong></p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token comment">#[必须]从服务器唯一ID</span>
<span class="token key attr-name">server-id</span><span class="token punctuation">=</span> <span class="token value attr-value">2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>可选</strong></p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token comment">#[可选]启用中继日志</span>
<span class="token key attr-name">relay-log</span><span class="token punctuation">=</span><span class="token value attr-value">mysql-relay</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>重启后台mysql服务，使配置生效。</p><blockquote><p>注意：主从机都关闭防火墙</p><p>service iptables stop #CentOS 6</p><p>systemctl stop firewalld.service #CentOS 7</p></blockquote><h3 id="_3-4-主机-建立账户并授权" tabindex="-1"><a class="header-anchor" href="#_3-4-主机-建立账户并授权" aria-hidden="true">#</a> 3. 4 主机：建立账户并授权</h3><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>#在主机MySQL里执行授权主从复制的命令
GRANT REPLICATION SLAVE ON *.* TO &#39;slave1&#39;@&#39;从机器数据库IP&#39; IDENTIFIED BY &#39;abc123&#39;;
#5.5,5.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意：如果使用的是MySQL8，需要如下的方式建立账户，并授权slave：</strong></p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>CREATE USER &#39;slave1&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39;;
GRANT REPLICATION SLAVE ON *.* TO &#39;slave1&#39;@&#39;%&#39;;

#此语句必须执行。否则见下面。
ALTER USER &#39;slave1&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;123456&#39;;

flush privileges;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>注意：在从机执行show slave status\\G时报错：</p><p>Last_IO_Error: error connecting to master &#39;slave1@192.168.1.150:3306&#39; - retry-time: 60 retries: 1 message: Authentication plugin &#39;caching_sha2_password&#39; reported error: Authentication requires secure connection.</p></blockquote><p>查询Master的状态，并记录下File和Position的值。</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>show master status;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+o+`" alt="image-20220329232741694"></p><ul><li>记录下File和Position的值</li></ul><blockquote><p>注意：执行完此步骤后 不要再操作主服务器MySQL ，防止主服务器状态值变化。</p></blockquote><h3 id="_3-5-从机-配置需要复制的主机" tabindex="-1"><a class="header-anchor" href="#_3-5-从机-配置需要复制的主机" aria-hidden="true">#</a> 3. 5 从机：配置需要复制的主机</h3><p><strong>步骤 1 ： 从机上复制主机的命令</strong></p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>CHANGE MASTER TO
MASTER_HOST=&#39;主机的IP地址&#39;,
MASTER_USER=&#39;主机用户名&#39;,
MASTER_PASSWORD=&#39;主机用户名的密码&#39;,
MASTER_LOG_FILE=&#39;mysql-bin.具体数字&#39;,
MASTER_LOG_POS=具体值;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>举例：</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>CHANGE MASTER TO
MASTER_HOST=&#39;192.168.1.150&#39;,MASTER_USER=&#39;slave1&#39;,MASTER_PASSWORD=&#39;123456&#39;,MASTER_LOG_F
ILE=&#39;atguigu-bin.000007&#39;,MASTER_LOG_POS= 154 ;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+p+'" alt="image-20220329232934516"></p><p><img src="'+c+`" alt="image-20220329232941780"></p><p>步骤 2 ：</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>#启动slave同步
START SLAVE;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+m+'" alt="image-20220329232952153"></p><p>如果报错：</p><p><img src="'+u+`" alt="image-20220329232958011"></p><p>可以执行如下操作，删除之前的relay_log信息。然后重新执行 CHANGE MASTER TO ...语句即可。</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>mysql&gt; reset slave; #删除SLAVE数据库的relaylog日志文件，并重新启用新的relaylog文件
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>接着，查看同步状态：</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>SHOW SLAVE STATUS\\G;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="`+g+'" alt="image-20220329233124775"></p><blockquote><p>上面两个参数都是Yes，则说明主从配置成功！</p></blockquote><p><strong>显式如下的情况，就是不正确的。可能错误的原因有：</strong></p><ol><li>网络不通</li><li>账户密码错误</li><li>防火墙</li><li>mysql配置文件问题</li><li>连接服务器时语法</li><li>主服务器mysql权限</li></ol><p><img src="'+v+`" alt="image-20220329233204316"></p><h3 id="_3-6-测试" tabindex="-1"><a class="header-anchor" href="#_3-6-测试" aria-hidden="true">#</a> 3. 6 测试</h3><p>主机新建库、新建表、insert记录，从机复制：</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>CREATE DATABASE atguigu_master_slave;
CREATE TABLE mytbl(id INT,NAME VARCHAR( 16 ));		
INSERT INTO mytbl VALUES( 1 , &#39;zhang3&#39;);
INSERT INTO mytbl VALUES( 2 ,@@hostname);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-7-停止主从同步" tabindex="-1"><a class="header-anchor" href="#_3-7-停止主从同步" aria-hidden="true">#</a> 3. 7 停止主从同步</h3><ul><li><p>停止主从同步命令：</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>stop slave;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>如何重新配置主从</p><p>如果停止从服务器复制功能，再使用需要重新配置主从。否则会报错如下：</p><p><img src="`+b+`" alt="image-20220329233352720"></p><p>重新配置主从，需要在从机上执行：</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>stop slave;

reset master; #删除Master中所有的binglog文件，并将日志索引文件清空，重新开始所有新的日志文件(慎用)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="_3-8-后续" tabindex="-1"><a class="header-anchor" href="#_3-8-后续" aria-hidden="true">#</a> 3. 8 后续</h3><h5 id="搭建主从复制-双主双从" tabindex="-1"><a class="header-anchor" href="#搭建主从复制-双主双从" aria-hidden="true">#</a> 搭建主从复制：双主双从</h5><p><img src="`+h+'" alt="image-20220329233433439"></p><p><img src="'+y+'" alt="image-20220329233448778"></p><h2 id="_4-同步数据一致性问题" tabindex="-1"><a class="header-anchor" href="#_4-同步数据一致性问题" aria-hidden="true">#</a> 4. 同步数据一致性问题</h2><p><strong>主从同步的要求：</strong></p><ul><li>读库和写库的数据一致(最终一致)；</li><li>写数据必须写到写库；</li><li>读数据必须到读库(不一定)；</li></ul><h3 id="_4-1-理解主从延迟问题" tabindex="-1"><a class="header-anchor" href="#_4-1-理解主从延迟问题" aria-hidden="true">#</a> 4. 1 理解主从延迟问题</h3><p>进行主从同步的内容是二进制日志，它是一个文件，在进行<code>网络传输</code>的过程中就一定会<code>存在主从延迟</code>（比如 500 ms），这样就可能造成用户在从库上读取的数据不是最新的数据，也就是主从同步中的<code>数据不一致性</code>问题。</p><p>**举例:**导致主从延迟的时间点主要包括以下三个:</p><p>1.主库A执行完成一个事务，写入binlog，我们把这个时刻记为T1;</p><p>2之后传给从库B，我们把从库B接收完这个binlog的时刻记为T2;</p><p>3．从库B执行完成这个事务，我们把这个时刻记为T3。</p><h3 id="_4-2-主从延迟问题原因" tabindex="-1"><a class="header-anchor" href="#_4-2-主从延迟问题原因" aria-hidden="true">#</a> 4. 2 主从延迟问题原因</h3><p>在网络正常的时候，日志从主库传给从库所需的时间是很短的，即T 2 - T 1 的值是非常小的。即，网络正常情况下，主备延迟的主要来源是备库接收完binlog和执行完这个事务之间的时间差。</p><p><strong>主备延迟最直接的表现是，从库消费中继日志（relay log）的速度，比主库生产binlog的速度要慢。</strong> 造成原因：</p><p>1 、从库的机器性能比主库要差</p><p>2 、从库的压力大</p><p>3 、大事务的执行</p><p><strong>举例 1 ：</strong> 一次性用delete语句删除太多数据</p><p>结论：后续再删除数据的时候，要控制每个事务删除的数据量，分成多次删除。</p><p><strong>举例 2 ：</strong> 一次性用insert...select插入太多数据</p><p><strong>举例: 3 ：</strong> 大表DDL</p><p>比如在主库对一张500W的表添加一个字段耗费了 10 分钟，那么从节点上也会耗费 10 分钟。</p><h3 id="_4-3-如何减少主从延迟" tabindex="-1"><a class="header-anchor" href="#_4-3-如何减少主从延迟" aria-hidden="true">#</a> 4. 3 如何减少主从延迟</h3><p><strong>若想要减少主从延迟的时间，可以采取下面的办法：</strong></p><ol><li>降低多线程大事务并发的概率，优化业务逻辑</li><li>优化SQL，避免慢SQL，<code>减少批量操作</code>，建议写脚本以update-sleep这样的形式完成。</li><li><code>提高从库机器的配置</code>，减少主库写binlog和从库读binlog的效率差。</li><li>尽量采用<code>短的链路</code>，也就是主库和从库服务器的距离尽量要短，提升端口带宽，减少binlog传输的网络延时。</li><li>实时性要求的业务读强制走主库，从库只做灾备，备份。</li></ol><h3 id="_4-4-如何解决一致性问题" tabindex="-1"><a class="header-anchor" href="#_4-4-如何解决一致性问题" aria-hidden="true">#</a> 4. 4 如何解决一致性问题</h3><p>如果操作的数据存储在同一个数据库中，那么对数据进行更新的时候，可以对记录加写锁，这样在读取的时候就不会发生数据不一致的情况。但这时从库的作用就是备份，并没有起到读写分离，分担主库读压力的作用。</p><p><img src="'+E+'" alt="image-20220329233714671"></p><p>读写分离情况下，解决主从同步中数据不一致的问题， 就是解决主从之间<code>数据复制方式</code>的问题，如果按照数据一致性<code>从弱到强来</code>进行划分，有以下 3 种复制方式。</p><h4 id="方法-1-异步复制" tabindex="-1"><a class="header-anchor" href="#方法-1-异步复制" aria-hidden="true">#</a> 方法 1 ：异步复制</h4><p>异步模式就是客户端提交COMMIT之后不需要等从库返回任何结果，而是直接将结果返回给客户端，这样做的好处是不会影响主库写的效率，但可能会存在主库宕机，而Binlog还没有同步到从库的情况，也就是此时的主库和从库数据不一致。这时候从从库中选择一个作为新主，那么新主则可能缺少原来主服务器中已提交的事务。所以，这种复制模式下的数据一致性是最弱的。</p><p><img src="'+_+'" alt="image-20220329233747296"></p><h4 id="方法-2-半同步复制" tabindex="-1"><a class="header-anchor" href="#方法-2-半同步复制" aria-hidden="true">#</a> 方法 2 ：半同步复制</h4><p>MySQL5.5版本之后开始支持半同步复制的方式。原理是在客户端提交COMMIT之后不直接将结果返回给客户端，而是等待至少有一个从库接收到了Binlog，并且写入到中继日志中，再返回给客户端。</p><p>这样做的好处就是提高了数据的一致性，当然相比于异步复制来说，至少多增加了一个网络连接的延迟，降低了主库写的效率。</p><p>在MySQL5.7版本中还增加了一个rpl_semi_sync_master_wait_for_slave_count参数，可以对应答的从库数量进行设置，默认为1，也就是说只要有1个从库进行了响应，就可以返回给客户端。如果将这个参数调大，可以提升数据一致性的强度，但也会增加主库等待从库响应的时间。</p><p><img src="'+S+'" alt="image-20220329233800680"></p><h4 id="方法-3-组复制" tabindex="-1"><a class="header-anchor" href="#方法-3-组复制" aria-hidden="true">#</a> 方法 3 ：组复制</h4><p>异步复制和半同步复制都无法最终保证数据的一致性问题，半同步复制是通过判断从库响应的个数来决定是否返回给客户端，虽然数据一致性相比于异步复制有提升，但仍然无法满足对数据一致性要求高的场景，比如金融领域。MGR 很好地弥补了这两种复制模式的不足。</p><p>组复制技术，简称 MGR（MySQL Group Replication）。是 MySQL 在 5.7.17 版本中推出的一种新的数据复制技术，这种复制技术是基于 Paxos 协议的状态机复制。</p><p><strong>MGR 是如何工作的</strong></p><p>首先我们将多个节点共同组成一个复制组，在<code>执行读写（RW）事务</code>的时候，需要通过一致性协议层（Consensus 层）的同意，也就是读写事务想要进行提交，必须要经过组里“大多数人”（对应 Node 节点）的同意，大多数指的是同意的节点数量需要大于 （N/2+1），这样才可以进行提交，而不是原发起方一个说了算。而针对<code>只读（RO）事务</code>则不需要经过组内同意，直接 COMMIT 即可。</p><p>在一个复制组内有多个节点组成，它们各自维护了自己的数据副本，并且在一致性协议层实现了原子消息和全局有序消息，从而保证组内数据的一致性。</p><p><img src="'+A+'" alt="image-20220329233847020"></p><p>MGR 将 MySQL 带入了数据强一致性的时代，是一个划时代的创新，其中一个重要的原因就是MGR 是基于 Paxos 协议的。Paxos 算法是由 2013 年的图灵奖获得者 Leslie Lamport 于 1990 年提出的，有关这个算法的决策机制可以搜一下。事实上，Paxos 算法提出来之后就作为<code>分布式一致性算法</code>被广泛应用，比如Apache 的 ZooKeeper 也是基于 Paxos 实现的。</p><h2 id="_5-知识延伸" tabindex="-1"><a class="header-anchor" href="#_5-知识延伸" aria-hidden="true">#</a> 5. 知识延伸</h2><p>在主从架构的配置中，如果想要采取读写分离的策略，我们可以<code>自己编写程序</code>，也可以通过<code>第三方的中间件</code>来实现。</p><ul><li><p>自己编写程序的好处就在于比较自主，我们可以自己判断哪些查询在从库上来执行，针对实时性要求高的需求，我们还可以考虑哪些查询可以在主库上执行。同时，程序直接连接数据库，减少了中间件层，相当于减少了性能损耗。</p></li><li><p>采用中间件的方法有很明显的优势，功能强大，使用简单。但因为在客户端和数据库之间增加了中间件层会有一些性能损耗，同时商业中间件也是有使用成本的。我们也可以考虑采取一些优秀的开源工具。</p><p><img src="'+R+'" alt="image-20220329234028528"></p></li></ul><p>① Cobar属于阿里B2B事业群，始于 2008 年，在阿里服役 3 年多，接管3000+个MySQL数据库的schema,集群日处理在线SQL请求 50 亿次以上。由于Cobar发起人的离职，Cobar停止维护。</p><p>② Mycat是开源社区在阿里cobar基础上进行二次开发，解决了cobar存在的问题，并且加入了许多新的功能在其中。青出于蓝而胜于蓝。</p><p>③ OneProxy基于MySQL官方的proxy思想利用c语言进行开发的，OneProxy是一款商业收费的中间件。舍弃了一些功能，专注在性能和稳定性上。</p><p>④ kingshard由小团队用go语言开发，还需要发展，需要不断完善。</p><p>⑤ Vitess是Youtube生产在使用，架构很复杂。不支持MySQL原生协议，使用需要大量改造成本。</p><p>⑥ Atlas是 360 团队基于mysql proxy改写，功能还需完善，高并发下不稳定。</p><p>⑦ MaxScale是mariadb（MySQL原作者维护的一个版本） 研发的中间件</p><p>⑧ MySQLRoute是MySQL官方Oracle公司发布的中间件</p><p><img src="'+q+'" alt="image-20220329234200370"></p><p><img src="'+T+'" alt="image-20220329234212660"></p><p>主备切换：</p><p><img src="'+k+'" alt="image-20220329234237134"></p><ul><li><p>主动切换</p></li><li><p>被动切换</p></li><li><p>如何判断主库出问题了？如何解决过程中的数据不一致性问题？</p></li></ul>',174),L=[x];function I(O,f){return a(),s("div",null,L)}const U=e(M,[["render",I],["__file","第18章_主从复制.html.vue"]]);export{U as default};
