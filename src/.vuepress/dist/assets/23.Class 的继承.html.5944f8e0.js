const e=JSON.parse('{"key":"v-809719c2","path":"/web/es6/23.Class%20%E7%9A%84%E7%BB%A7%E6%89%BF.html","title":"Class 的继承","lang":"zh-CN","frontmatter":{"title":"Class 的继承","category":["es6"],"tag":["ECMASCRIPT","javascript"],"sticky":false,"star":false,"article":true,"timeline":true,"description":"简介 Class 可以通过extends关键字实现继承，让子类继承父类的属性和方法。extends 的写法比 ES5 的原型链继承，要清晰和方便很多。 上面示例中，Point是父类，ColorPoint是子类，它通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。 下...","head":[["meta",{"property":"og:url","content":"https://Ragnarokoo.github.io/LearningNotes/web/es6/23.Class%20%E7%9A%84%E7%BB%A7%E6%89%BF.html"}],["meta",{"property":"og:site_name","content":"📚全栈开发学习指南"}],["meta",{"property":"og:title","content":"Class 的继承"}],["meta",{"property":"og:description","content":"简介 Class 可以通过extends关键字实现继承，让子类继承父类的属性和方法。extends 的写法比 ES5 的原型链继承，要清晰和方便很多。 上面示例中，Point是父类，ColorPoint是子类，它通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。 下..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2023-05-31T09:16:41.000Z"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:tag","content":"ECMASCRIPT"}],["meta",{"property":"article:tag","content":"javascript"}],["meta",{"property":"article:modified_time","content":"2023-05-31T09:16:41.000Z"}]]},"excerpt":"","headers":[{"level":2,"title":"简介","slug":"简介","link":"#简介","children":[]},{"level":2,"title":"私有属性和私有方法的继承","slug":"私有属性和私有方法的继承","link":"#私有属性和私有方法的继承","children":[]},{"level":2,"title":"静态属性和静态方法的继承","slug":"静态属性和静态方法的继承","link":"#静态属性和静态方法的继承","children":[]},{"level":2,"title":"Object.getPrototypeOf()","slug":"object-getprototypeof","link":"#object-getprototypeof","children":[]},{"level":2,"title":"super 关键字","slug":"super-关键字","link":"#super-关键字","children":[]},{"level":2,"title":"类的 prototype 属性和__proto__属性","slug":"类的-prototype-属性和-proto-属性","link":"#类的-prototype-属性和-proto-属性","children":[{"level":3,"title":"实例的 __proto__ 属性","slug":"实例的-proto-属性","link":"#实例的-proto-属性","children":[]}]},{"level":2,"title":"原生构造函数的继承","slug":"原生构造函数的继承","link":"#原生构造函数的继承","children":[]},{"level":2,"title":"Mixin 模式的实现","slug":"mixin-模式的实现","link":"#mixin-模式的实现","children":[]}],"git":{"createdTime":1685524601000,"updatedTime":1685524601000,"contributors":[{"name":"kirito","email":"2724964601@qq.com","commits":1}]},"readingTime":{"minutes":16.1,"words":4830},"filePathRelative":"web/es6/23.Class 的继承.md","localizedDate":"2023年5月31日"}');export{e as data};
