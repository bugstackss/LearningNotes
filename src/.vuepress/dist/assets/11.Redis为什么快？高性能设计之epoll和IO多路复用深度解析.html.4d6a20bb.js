const e=JSON.parse('{"key":"v-52b13e7c","path":"/notes/db/redis_pro/11.Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB%EF%BC%9F%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%BE%E8%AE%A1%E4%B9%8Bepoll%E5%92%8CIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90.html","title":"十一、Redis为什么快？高性能设计之epoll和IO多路复用深度解析","lang":"zh-CN","frontmatter":{"title":"十一、Redis为什么快？高性能设计之epoll和IO多路复用深度解析","category":["redis"],"tag":["redis","NOSQL","K,V缓存数据库","非关系型数据库"],"sticky":false,"star":false,"article":true,"timeline":true,"description":"01、before 多路复用要解决的问题 并发多客户端连接，在多路复用之前最简单和典型的方案：同步阻塞网络IO模型 这种模式的特点就是用一个进程来处理一个网络连接(一个用户请求)，比如一段典型的示例代码如下。 直接调用 recv 函数从一个 socket 上读取数据。 我们来总结一下这种方式： 优点就是这种方式非常容易让人理解，写起代码来非常的自然，符...","head":[["meta",{"property":"og:url","content":"https://Ragnarokoo.github.io/LearningNotes/notes/db/redis_pro/11.Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB%EF%BC%9F%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%BE%E8%AE%A1%E4%B9%8Bepoll%E5%92%8CIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90.html"}],["meta",{"property":"og:site_name","content":"📚全栈开发学习指南"}],["meta",{"property":"og:title","content":"十一、Redis为什么快？高性能设计之epoll和IO多路复用深度解析"}],["meta",{"property":"og:description","content":"01、before 多路复用要解决的问题 并发多客户端连接，在多路复用之前最简单和典型的方案：同步阻塞网络IO模型 这种模式的特点就是用一个进程来处理一个网络连接(一个用户请求)，比如一段典型的示例代码如下。 直接调用 recv 函数从一个 socket 上读取数据。 我们来总结一下这种方式： 优点就是这种方式非常容易让人理解，写起代码来非常的自然，符..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://Ragnarokoo.github.io/LearningNotes/"}],["meta",{"property":"og:updated_time","content":"2023-05-31T09:16:41.000Z"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"十一、Redis为什么快？高性能设计之epoll和IO多路复用深度解析"}],["meta",{"property":"article:tag","content":"redis"}],["meta",{"property":"article:tag","content":"NOSQL"}],["meta",{"property":"article:tag","content":"K,V缓存数据库"}],["meta",{"property":"article:tag","content":"非关系型数据库"}],["meta",{"property":"article:modified_time","content":"2023-05-31T09:16:41.000Z"}]]},"excerpt":"","headers":[{"level":2,"title":"01、before","slug":"_01、before","link":"#_01、before","children":[{"level":3,"title":"多路复用要解决的问题","slug":"多路复用要解决的问题","link":"#多路复用要解决的问题","children":[]},{"level":3,"title":"结论","slug":"结论","link":"#结论","children":[]}]},{"level":2,"title":"02、I/O多路复用模型","slug":"_02、i-o多路复用模型","link":"#_02、i-o多路复用模型","children":[{"level":3,"title":"是什么？","slug":"是什么","link":"#是什么","children":[]},{"level":3,"title":"Redis单线程如何处理那么多并发客户端连接，为什么单线程，为什么快？","slug":"redis单线程如何处理那么多并发客户端连接-为什么单线程-为什么快","link":"#redis单线程如何处理那么多并发客户端连接-为什么单线程-为什么快","children":[]},{"level":3,"title":"参考《Redis设计与实现》","slug":"参考《redis设计与实现》","link":"#参考《redis设计与实现》","children":[]},{"level":3,"title":"吃米线开始，读读read…","slug":"吃米线开始-读读read","link":"#吃米线开始-读读read","children":[]},{"level":3,"title":"Unix网络编程中的物种IO模型","slug":"unix网络编程中的物种io模型","link":"#unix网络编程中的物种io模型","children":[]},{"level":3,"title":"Java验证","slug":"java验证","link":"#java验证","children":[]}]}],"git":{"createdTime":1685524601000,"updatedTime":1685524601000,"contributors":[{"name":"kirito","email":"2724964601@qq.com","commits":1}]},"readingTime":{"minutes":30.14,"words":9042},"filePathRelative":"notes/db/redis_pro/11.Redis为什么快？高性能设计之epoll和IO多路复用深度解析.md","localizedDate":"2023年5月31日"}');export{e as data};
