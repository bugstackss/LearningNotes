import{_ as n}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as r,c as d,d as e,e as l,b as s,a as i,r as t}from"./app.9b10ba0a.js";const p="/assets/2023-03-30-21-07-58-image.20612510.png",c="/assets/2023-03-30-21-08-40-image.a0606700.png",h="/assets/2023-03-30-21-13-21-image.0178d3bc.png",o={},u=i(`<h2 id="_01、面试题" tabindex="-1"><a class="header-anchor" href="#_01、面试题" aria-hidden="true">#</a> 01、面试题</h2><ol><li><p><code>如何优化频繁命令晚返造成的性能瓶颈？</code></p></li><li><p>问题由来？</p></li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Redis是一种基于客户端-服务端模型以及请求/响应协议的TCP服务。一个请求会遵循以下步骤：

1 客户端向服务端发送命令分四步(发送命令→命令排队→命令执行→返回结果)，并监听Socket返回，通常以阻塞模式等待服务端响应。

2 服务端处理命令，并将结果返回给客户端。

**上述两步称为：Round Trip Time(简称RTT,数据包往返于两端的时间)，问题笔记最下方**
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+p+'" alt=""></p><p>如果同时需要执行大量的命令，那么就要等待上一条命令应答后再执行，这中间不仅仅多了RTT（Round Time Trip），而且还频繁调用系统IO，发送网络请求，同时需要redis调用多次read()和write()系统方法，系统方法会将数据从用户态转移到内核态，这样就会对进程上下文有比较大的影响了，性能不太好，o(╥﹏╥)o</p><h2 id="_02、是什么" tabindex="-1"><a class="header-anchor" href="#_02、是什么" aria-hidden="true">#</a> 02、是什么？</h2><h3 id="解决思路" tabindex="-1"><a class="header-anchor" href="#解决思路" aria-hidden="true">#</a> 解决思路</h3><p>管道(pipeline)可以一次性发送多条命令给服务端，服务端依次处理完完毕后，通过一条响应一次性将结果返回，通过减少客户端与redis的通信次数来实现降低往返延时时间。pipeline实现的原理是队列，先进先出特性就保证数据的顺序性。</p><p><img src="'+c+'" alt=""></p><blockquote><p>引出管道这个概念</p></blockquote><h3 id="官网" tabindex="-1"><a class="header-anchor" href="#官网" aria-hidden="true">#</a> 官网</h3>',11),_={href:"https://redis.io/docs/manual/pipelining/",target:"_blank",rel:"noopener noreferrer"},m=i('<h3 id="定义" tabindex="-1"><a class="header-anchor" href="#定义" aria-hidden="true">#</a> 定义</h3><p>Pipeline是为了解决RTT往返回时，仅仅是将命令打包一次性发送，对整个Redis的执行不造成其他任意影响</p><h3 id="一句话" tabindex="-1"><a class="header-anchor" href="#一句话" aria-hidden="true">#</a> 一句话</h3><p>批处理命令变种优化措施，类似Redis的原生批命令（mget和mset）</p><h2 id="_03、案例演示" tabindex="-1"><a class="header-anchor" href="#_03、案例演示" aria-hidden="true">#</a> 03、案例演示</h2><ul><li>当堂演示</li></ul><p><img src="'+h+'" alt=""></p><h2 id="_04、小总结" tabindex="-1"><a class="header-anchor" href="#_04、小总结" aria-hidden="true">#</a> 04、小总结</h2><h3 id="pieline与原生批量命令对比" tabindex="-1"><a class="header-anchor" href="#pieline与原生批量命令对比" aria-hidden="true">#</a> Pieline与原生批量命令对比</h3><ul><li><p>原生批量命令是原子性（例如：mset、mget），<code>pipeline是非原子性</code></p></li><li><p>原生批量命令一次只能执行一种命令，pipeline支持批量执行不同命令</p></li><li><p>原生批命令是服务端实现，而pipeline需要服务端与客户端共同完成</p></li></ul><h3 id="pipeline与事务的对比" tabindex="-1"><a class="header-anchor" href="#pipeline与事务的对比" aria-hidden="true">#</a> Pipeline与事务的对比</h3><ul><li><p>事务具有原子性，管道不具有原子性</p></li><li><p>管道一次性价格多条命令发送到服务器，事务是一条一条的发，事务只有在接收到exec命令后才会执行，管道不会</p></li><li><p>执行事务时会阻塞其他命令的执行，而执行管道中的命令时不会</p></li></ul><h3 id="使用pipeline注意事项" tabindex="-1"><a class="header-anchor" href="#使用pipeline注意事项" aria-hidden="true">#</a> 使用Pipeline注意事项</h3><ul><li>pipeline缓冲的指令只是会依次执行，不保证原子性，如何执行中指令发生异常，将会继续执行后续的指令</li><li>使用pipeline组装的命令个数不能太多，不然数据量过大客户端阻塞的时间可能过久，同时服务端此时也被迫回复一个队列答复，占用很多内存！</li></ul>',14);function b(x,f){const a=t("ExternalLinkIcon");return r(),d("div",null,[u,e("blockquote",null,[e("p",null,[e("a",_,[l("https://redis.io/docs/manual/pipelining/"),s(a)])])]),m])}const T=n(o,[["render",b],["__file","六、Redis管道.html.vue"]]);export{T as default};
