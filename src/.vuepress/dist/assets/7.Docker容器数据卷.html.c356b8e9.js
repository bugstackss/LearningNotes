import{_ as a}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as e,c as s,a as n}from"./app.9b10ba0a.js";const r="/assets/2023-05-18-21-30-46-image.0a2da7fa.png",p="/assets/2023-05-18-21-34-50-image.d936d8b2.png",i="/assets/2023-05-18-21-35-46-image.1b4e4de6.png",t="/assets/2023-05-18-21-36-24-image.a030d105.png",o="/assets/2023-05-18-21-37-07-image.56449a47.png",c="/assets/2023-05-18-21-37-19-image.18ef68a1.png",l="/assets/2023-05-18-21-38-28-image.ee85831b.png",d="/assets/2023-05-18-21-39-55-image.5b5adc6f.png",u="/assets/2023-05-18-21-40-02-image.46a0c03a.png",m="/assets/2023-05-18-21-40-32-image.3ea4955b.png",b={},v=n(`<h2 id="一、❌坑-容器卷记得加入" tabindex="-1"><a class="header-anchor" href="#一、❌坑-容器卷记得加入" aria-hidden="true">#</a> 一、❌坑：容器卷记得加入</h2><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token parameter variable">--privileged</span><span class="token operator">=</span>true
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>why</p></blockquote><p>Docker挂载主机目录访问<strong>如果出现cannot open directory .: Permission denied</strong></p><p>解决办法：在挂载目录后多加一个--privileged=true参数即可</p><p>如果是CentOS7安全模块会比之前系统版本加强，不安全的会先禁止，所以目录挂载的情况被默认为不安全的行为，</p><p>在SELinux里面挂载目录被禁止掉了额，如果要开启，我们一般使用--privileged=true命令，扩大容器的权限解决挂载目录没有权限的问题，也即</p><p>使用该参数，container内的root拥有真正的root权限，否则，container内的root只是外部的一个普通用户权限。</p><h2 id="二、回顾下上一讲的知识点-参数v" tabindex="-1"><a class="header-anchor" href="#二、回顾下上一讲的知识点-参数v" aria-hidden="true">#</a> 二、回顾下上一讲的知识点，参数V</h2><p><strong>还记得蓝色框框中的内容吗？</strong></p><p><img src="`+r+`" alt=""></p><h2 id="三、是什么" tabindex="-1"><a class="header-anchor" href="#三、是什么" aria-hidden="true">#</a> 三、是什么</h2><p>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性：</p><p>卷的设计目的就是<code>数据的持久化</code>，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷</p><hr><p>一句话：有点类似我们Redis李米娜的rdb和aof文件，将docker容器内的数据保存进宿主机的磁盘中，运行一个带有容器卷存储功能的容器示例。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--privileged</span> <span class="token parameter variable">-v</span> /宿主机绝对路径目录:/容器内目录 镜像名
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="四、能干嘛" tabindex="-1"><a class="header-anchor" href="#四、能干嘛" aria-hidden="true">#</a> 四、能干嘛</h2><p>*  将运用与运行的环境打包镜像，run后形成容器实例运行 ，但是我们对数据的要求希望是<code>持久化的</code></p><p>Docker容器产生的数据，如果不备份，那么当容器实例删除后，容器内的数据自然也就没有了。</p><p>为了能保存数据在docker中我们使用卷。</p><p>特点：</p><p>1：数据卷可在容器之间共享或重用数据</p><p>2：卷中的更改可以直接实时生效，爽</p><p>3：数据卷中的更改不会包含在镜像的更新中</p><p>4：数据卷的生命周期一直持续到没有容器使用它为止</p><h2 id="五、数据卷案例" tabindex="-1"><a class="header-anchor" href="#五、数据卷案例" aria-hidden="true">#</a> 五、数据卷案例</h2><p>1.宿主vs容器之间映射添加容器卷</p><blockquote><p>命令</p></blockquote><p>公式：docker run -it -v /宿主机目录:/容器内目录 ubuntu /bin/bash</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--name</span> myu3 <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true <span class="token parameter variable">-v</span> /tmp/myHostData:/tmp/myDockerData ubuntu /bin/bash
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="`+p+`" alt=""></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--privileged</span> <span class="token parameter variable">-v</span> /宿主机绝对路径目录:/容器内目录 镜像名
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>查看数据卷是否挂载成功</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> inspect 容器ID
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="`+i+'" alt=""></p><blockquote><p>容器和宿主机之间数据共享</p></blockquote><p>1  docker修改，主机同步获得</p><p>2 主机修改，docker同步获得</p><p>3 docker容器stop，主机修改，docker容器重启看数据是否同步。</p><p><img src="'+t+'" alt=""></p><p>2.读写规则映射添加说明</p><blockquote><p>默认（读写）</p></blockquote><p><img src="'+o+'" alt=""></p><p>rw = read + write</p><p><img src="'+c+`" alt=""></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--privileged</span> <span class="token parameter variable">-v</span> /宿主机绝对路径目录:/容器内目录 镜像名
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>默认同上案例，默认就是rw</p><blockquote><p>只读</p></blockquote><p>容器内部被限制，只能读取不能写</p><p><img src="`+l+`" alt=""></p><p>/容器目录:ro 镜像名               就能完成功能，此时容器自己只能读取不能写</p><p>ro = read only</p><p>此时如果宿主机写入内容，可以同步给容器内，容器可以读取到。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--privileged</span> <span class="token parameter variable">-v</span> /宿主机绝对路径目录:/容器内目录:ro 镜像名
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>3.卷的继承和共享</p><blockquote><p>容器1完成和宿主机的映射</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-it</span>  <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true <span class="token parameter variable">-v</span> /mydocker/u:/tmp <span class="token parameter variable">--name</span> u1 ubuntu    
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="`+d+'" alt=""></p><p><img src="'+u+'" alt=""></p><blockquote><p>容器2继承容器1的卷规则</p></blockquote><p><img src="'+m+`" alt=""></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true --volumes-from 父类 <span class="token parameter variable">--name</span> u2 ubuntu
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,63),g=[v];function k(h,_){return e(),s("div",null,g)}const q=a(b,[["render",k],["__file","7.Docker容器数据卷.html.vue"]]);export{q as default};
