import{_ as s}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as a,c as e,a as o}from"./app.9b10ba0a.js";const t="/assets/2023-05-18-18-04-57-image.b5061118.png",n="/assets/2023-05-18-18-06-08-image.6c8eeace.png",p="/assets/2023-05-18-18-06-55-image.8150a763.png",i="/assets/2023-05-18-18-07-12-image.c63b103b.png",c="/assets/2023-05-18-18-10-08-image.3153bd21.png",r="/assets/2023-05-18-18-13-35-image.9c8a2ed5.png",l="/assets/2023-05-18-18-14-12-image.a751c489.png",m="/assets/2023-05-18-18-14-35-image.af44c646.png",u="/assets/2023-05-18-18-14-44-image.de9a5e32.png",d="/assets/2023-05-18-18-15-20-image.38f16484.png",b="/assets/2023-05-18-18-15-27-image.ffab97ab.png",g="/assets/2023-05-18-18-15-57-image.e53abcd8.png",k="/assets/2023-05-18-18-16-55-image.c291714b.png",_={},v=o('<h2 id="一、是什么" tabindex="-1"><a class="header-anchor" href="#一、是什么" aria-hidden="true">#</a> 一、是什么</h2><blockquote><p><strong>是什么？</strong></p></blockquote><p><strong>镜像</strong></p><p>是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好形成一个可交付的运行环境(包括代码、运行时需要的库、环境变量和配置文件等)，这个打包好的运行环境就是image镜像文件。</p><p>只有通过这个镜像文件才能生成Docker容器实例(类似Java中new出来一个对象)。</p><blockquote><p><strong>镜像的分层</strong></p></blockquote><p>以我们的pull为例，在下载的过程中我们可以看到docker的镜像好像是在一层一层的在下载</p><p><img src="'+t+'" alt=""></p><blockquote><p>UnionFS（联合文件系统）</p></blockquote><p>UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持<code>对文件系统的修改作为一次提交来一层层的叠加</code>，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。<strong>镜像可以通过分层来进行继承</strong>，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p><p><img src="'+n+'" alt=""></p><p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p><blockquote><p>Docker镜像加载原理：</p></blockquote><p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。</p><p>bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，<code>在Docker镜像的最底层是引导文件系统bootfs</code>。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</p><p>rootfs (root file system) ，在bootfs之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。</p><p><img src="'+p+'" alt=""></p><p><strong>平时我们安装进虚拟机的CentOS都是好几个G，为什么docker这里才200M？？</strong></p><p><img src="'+i+'" alt=""></p><p>对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别, 因此不同的发行版可以公用bootfs。</p><blockquote><p>为什么Docker镜像要采用这种分层结构呢？</p></blockquote><p>镜像分层最大的一个好处就是共享资源，方便复制迁移，就是为了复用。</p><p>比如说有多个镜像都从相同的 base 镜像构建而来，那么 Docker Host 只需在磁盘上保存一份 base 镜像；</p><p>同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p><h2 id="二、重点理解" tabindex="-1"><a class="header-anchor" href="#二、重点理解" aria-hidden="true">#</a> 二、重点理解</h2><p><strong>Docker镜像层都是只读的，容器层是可写的</strong></p><p>当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作”容器层“，”容器层“之下的都叫”镜像层“。</p><p>当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</p><p>所有对容器的改动 - 无论添加、删除、还是修改文件都只会发生在容器层中。只有容器层是可写的，容器层下面的所有镜像层都是只读的。</p><p><img src="'+c+`" alt=""></p><h2 id="三、docker镜像commit操作案例" tabindex="-1"><a class="header-anchor" href="#三、docker镜像commit操作案例" aria-hidden="true">#</a> 三、Docker镜像commit操作案例</h2><p>docker commit提交容器副本使之成为一个新的镜像</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> commit <span class="token parameter variable">-m</span><span class="token operator">=</span><span class="token string">&quot;提交的描述信息&quot;</span> <span class="token parameter variable">-a</span><span class="token operator">=</span><span class="token string">&quot;作者&quot;</span> 容器ID 要创建的目标镜像名:<span class="token punctuation">[</span>标签名<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>案例演示ubuntu安装vim</p></blockquote><ul><li><p>从Hub上下载镜像到本地并成功运行</p></li><li><p>原始的Ubuntu镜像是不带着vim命令的</p></li></ul><p><img src="`+r+'" alt=""></p><ul><li>外网连通的情况下，安装vim</li></ul><p><img src="'+l+`" alt=""></p><p>docker容器内执行上述两条命令：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">apt-get</span> update

<span class="token function">apt-get</span> <span class="token parameter variable">-y</span> <span class="token function">install</span> <span class="token function">vim</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+m+'" alt=""></p><p><img src="'+u+'" alt=""></p><ul><li>安装完成后，commit我们自己的新镜像</li></ul><p><img src="'+d+'" alt=""></p><p><img src="'+b+'" alt=""></p><ul><li>启动我们的新镜像    并和原来的对比</li></ul><p><img src="'+g+`" alt=""></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> commit <span class="token parameter variable">-m</span><span class="token operator">=</span><span class="token string">&quot;add vim cmd ok&quot;</span> <span class="token parameter variable">-a</span><span class="token operator">=</span><span class="token string">&quot;sakura&quot;</span> ecc9a181c772 sakura/myubuntu:1.1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>1 官网是默认下载的Ubuntu没有vim命令</p><p>2我们自己commit构建的镜像，新增加了vim功能，可以成功使用。</p><blockquote><p>小总结</p></blockquote><p>Docker中的镜像分层，<code>支持通过扩展现有镜像，创建新的镜像</code>。类似Java继承于一个Base基础类，自己再按需扩展。</p><p>新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层</p><p><img src="`+k+'" alt=""></p>',54),f=[v];function h(q,x){return a(),e("div",null,f)}const S=s(_,[["render",h],["__file","4.Docker镜像.html.vue"]]);export{S as default};
