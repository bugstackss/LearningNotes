import{_ as l}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as a,c,d as e,b as o,e as n,a as t,r as i}from"./app.9b10ba0a.js";const d={},r=e("p",null,"TypeScript 提供了非常多的编译选项，但是官方文档对每一项的解释很抽象，这一章会详细介绍每一个选项的作用，并给出对应的示例。",-1),p=e("p",null,"索引（点击选项跳转到详细介绍）：",-1),u=e("thead",null,[e("tr",null,[e("th",null,"选项"),e("th",null,"类型"),e("th",null,"默认值"),e("th",null,"描述")])],-1),m={href:"https://ts.xcatliu.com/engineering/compiler-options.html#allowjs",target:"_blank",rel:"noopener noreferrer"},h=e("code",null,"allowJs",-1),_=e("td",null,[e("code",null,"boolean")],-1),v=e("td",null,[e("code",null,"false")],-1),f=e("td",null,"允许编译 js 文件",-1),b={href:"https://ts.xcatliu.com/engineering/compiler-options.html#allowsyntheticdefaultimports",target:"_blank",rel:"noopener noreferrer"},k=e("code",null,"allowSyntheticDefaultImports",-1),x=e("td",null,[e("code",null,"boolean")],-1),g=e("td",null,[e("code",null,"false")],-1),y=e("td",null,"允许对不包含默认导出的模块使用默认导入。这个选项不会影响生成的代码，只会影响类型检查。",-1),w=e("h2",{id:"allowjs",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#allowjs","aria-hidden":"true"},"#"),n(" allowJs")],-1),j=e("blockquote",null,[e("p",null,"允许编译 js 文件。")],-1),I=e("p",null,[n("设置为 "),e("code",null,"true"),n(" 时，js 文件会被 tsc 编译，否则不会。一般在项目中 js, ts 混合开发时需要设置。")],-1),R={href:"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/compiler-options/01-allowJs",target:"_blank",rel:"noopener noreferrer"},S=t(`<div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 设置为 true 时，编译后的文件包含 foo.js</span>
├── lib
│   ├── foo.js
│   └── index.js
├── src
│   ├── foo.js
│   └── index.ts
├── package.json
└── tsconfig.json
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 设置为 false 时，编译后的文件不包含 foo.js</span>
├── lib
│   └── index.js
├── src
│   ├── foo.js
│   └── index.ts
├── package.json
└── tsconfig.json
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="allowsyntheticdefaultimports" tabindex="-1"><a class="header-anchor" href="#allowsyntheticdefaultimports" aria-hidden="true">#</a> allowSyntheticDefaultImports</h2><blockquote><p>允许对不包含默认导出的模块使用默认导入。这个选项不会影响生成的代码，只会影响类型检查。</p></blockquote><p><code>export = foo</code> 是 ts 为了兼容 commonjs 创造的语法，它对应于 commonjs 中的 <code>module.exports = foo</code>。</p><p>在 ts 中，如果要引入一个通过 <code>export = foo</code> 导出的模块，标准的语法是 <code>import foo = require(&#39;foo&#39;)</code>，或者 <code>import * as foo from &#39;foo&#39;</code>。</p><p>但由于历史原因，我们已经习惯了使用 <code>import foo from &#39;foo&#39;</code>。</p><p>这个选项就是为了解决这个问题。当它设置为 <code>true</code> 时，允许使用 <code>import foo from &#39;foo&#39;</code> 来导入一个通过 <code>export = foo</code> 导出的模块。当它设置为 <code>false</code> 时，则不允许，会报错。</p>`,8),q=e("code",null,"export = foo",-1),D={href:"https://ts.xcatliu.com/basics/declaration-files#export-1",target:"_blank",rel:"noopener noreferrer"},N=e("code",null,"export = foo",-1),V=t(`<p>比如 React 的声明文件中，就是通过 <code>export = React</code> 来导出类型：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">export</span> <span class="token operator">=</span> React<span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">as</span> <span class="token keyword">namespace</span> React<span class="token punctuation">;</span>

<span class="token keyword">declare</span> <span class="token keyword">namespace</span> React <span class="token punctuation">{</span>
    <span class="token comment">// 声明 React 的类型</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,2),B=e("code",null,"import React from 'react'",-1),E={href:"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/compiler-options/02-allowSyntheticDefaultImports",target:"_blank",rel:"noopener noreferrer"},J=t(`<div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">&#39;react&#39;</span><span class="token punctuation">;</span>
<span class="token comment">// Module &#39;&quot;typescript-tutorial/examples/compiler-options/02-allowSyntheticDefaultImports/false/node_modules/@types/react/index&quot;&#39; can only be default-imported using the &#39;esModuleInterop&#39; flagts(1259)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>解决办法就是将 <code>allowSyntheticDefaultImports</code> 设置为 <code>true</code>。</p>`,2);function L(M,T){const s=i("ExternalLinkIcon");return a(),c("div",null,[r,p,e("table",null,[u,e("tbody",null,[e("tr",null,[e("td",null,[e("a",m,[h,o(s)])]),_,v,f]),e("tr",null,[e("td",null,[e("a",b,[k,o(s)])]),x,g,y])])]),w,j,I,e("p",null,[e("a",R,[n("查看示例"),o(s)])]),S,e("p",null,[n("当然，我们一般不会在 ts 文件中使用 "),q,n(" 来导出模块，而是在"),e("a",D,[n("写（符合 commonjs 规范的）第三方库的声明文件"),o(s)]),n("时，才会用到 "),N,n(" 来导出类型。")]),V,e("p",null,[n("此时若我们通过 "),B,n(" 来导入 react 则会报错，"),e("a",E,[n("查看示例"),o(s)]),n(" ：")]),J])}const A=l(d,[["render",L],["__file","24. 编译选项.html.vue"]]);export{A as default};
