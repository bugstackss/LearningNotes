const l=JSON.parse('{"key":"v-154bfbfa","path":"/notes/javacore/java/17%E3%80%81%E5%8F%8D%E5%B0%84%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.html","title":"17、反射与动态代理","lang":"zh-CN","frontmatter":{"title":"17、反射与动态代理","category":["Java"],"tag":["Java"],"sticky":false,"star":false,"article":true,"timeline":true,"description":"01、Java反射机制概述 Reflection（反射）是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。 加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象...","head":[["meta",{"property":"og:url","content":"https://Ragnarokoo.github.io/LearningNotes/notes/javacore/java/17%E3%80%81%E5%8F%8D%E5%B0%84%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.html"}],["meta",{"property":"og:site_name","content":"📚全栈开发学习指南"}],["meta",{"property":"og:title","content":"17、反射与动态代理"}],["meta",{"property":"og:description","content":"01、Java反射机制概述 Reflection（反射）是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。 加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://Ragnarokoo.github.io/LearningNotes/"}],["meta",{"property":"og:updated_time","content":"2023-05-31T09:16:41.000Z"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"17、反射与动态代理"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:modified_time","content":"2023-05-31T09:16:41.000Z"}]]},"excerpt":"","headers":[{"level":2,"title":"01、Java反射机制概述","slug":"_01、java反射机制概述","link":"#_01、java反射机制概述","children":[{"level":3,"title":"1.1、使用反射，实现同上的操作","slug":"_1-1、使用反射-实现同上的操作","link":"#_1-1、使用反射-实现同上的操作","children":[]},{"level":3,"title":"1.2、反射的强大：调用类的私有结构","slug":"_1-2、反射的强大-调用类的私有结构","link":"#_1-2、反射的强大-调用类的私有结构","children":[]}]},{"level":2,"title":"02、理解Class类并获取Class实例","slug":"_02、理解class类并获取class实例","link":"#_02、理解class类并获取class实例","children":[{"level":3,"title":"2.3、Class类的理解","slug":"_2-3、class类的理解","link":"#_2-3、class类的理解","children":[]},{"level":3,"title":"2.4、获取Class实例的4种方式","slug":"_2-4、获取class实例的4种方式","link":"#_2-4、获取class实例的4种方式","children":[]},{"level":3,"title":"2.5、Class实例对应的结构的说明","slug":"_2-5、class实例对应的结构的说明","link":"#_2-5、class实例对应的结构的说明","children":[]}]},{"level":2,"title":"03、类的加载与ClassLoader的理解","slug":"_03、类的加载与classloader的理解","link":"#_03、类的加载与classloader的理解","children":[{"level":3,"title":"3.6、了解：类的加载过程","slug":"_3-6、了解-类的加载过程","link":"#_3-6、了解-类的加载过程","children":[]},{"level":3,"title":"3.7、了解：什么时候会发生类初始化？","slug":"_3-7、了解-什么时候会发生类初始化","link":"#_3-7、了解-什么时候会发生类初始化","children":[]},{"level":3,"title":"3.8、ClassLoader的理解","slug":"_3-8、classloader的理解","link":"#_3-8、classloader的理解","children":[]},{"level":3,"title":"3.9、使用ClassLoader加载配置文件","slug":"_3-9、使用classloader加载配置文件","link":"#_3-9、使用classloader加载配置文件","children":[]}]},{"level":2,"title":"04、通过反射，创建运行时类的对象","slug":"_04、通过反射-创建运行时类的对象","link":"#_04、通过反射-创建运行时类的对象","children":[{"level":3,"title":"4.1、举例体会反射的动态性","slug":"_4-1、举例体会反射的动态性","link":"#_4-1、举例体会反射的动态性","children":[]}]},{"level":2,"title":"05、获取运行时类的完整结构","slug":"_05、获取运行时类的完整结构","link":"#_05、获取运行时类的完整结构","children":[{"level":3,"title":"5.1、提供结构丰富Person类","slug":"_5-1、提供结构丰富person类","link":"#_5-1、提供结构丰富person类","children":[]},{"level":3,"title":"5.2、获取运行时类的属性结构及其内部结构","slug":"_5-2、获取运行时类的属性结构及其内部结构","link":"#_5-2、获取运行时类的属性结构及其内部结构","children":[]},{"level":3,"title":"5.3、获取运行时类的方法结构","slug":"_5-3、获取运行时类的方法结构","link":"#_5-3、获取运行时类的方法结构","children":[]},{"level":3,"title":"5.4、获取运行时类的方法的内部结构","slug":"_5-4、获取运行时类的方法的内部结构","link":"#_5-4、获取运行时类的方法的内部结构","children":[]},{"level":3,"title":"5.5、获取运行时类的构造器结构","slug":"_5-5、获取运行时类的构造器结构","link":"#_5-5、获取运行时类的构造器结构","children":[]},{"level":3,"title":"5.6、获取运行时类的父类及父类的泛型","slug":"_5-6、获取运行时类的父类及父类的泛型","link":"#_5-6、获取运行时类的父类及父类的泛型","children":[]},{"level":3,"title":"5.7、获取运行时类的接口、所在包、注解等","slug":"_5-7、获取运行时类的接口、所在包、注解等","link":"#_5-7、获取运行时类的接口、所在包、注解等","children":[]}]},{"level":2,"title":"06、调用运行时类的指定结构","slug":"_06、调用运行时类的指定结构","link":"#_06、调用运行时类的指定结构","children":[{"level":3,"title":"6.1、调用运行时类中的指定属性","slug":"_6-1、调用运行时类中的指定属性","link":"#_6-1、调用运行时类中的指定属性","children":[]},{"level":3,"title":"6.2、调用运行时类中的指定方法","slug":"_6-2、调用运行时类中的指定方法","link":"#_6-2、调用运行时类中的指定方法","children":[]},{"level":3,"title":"6.3、调用运行时类中的指定构造器","slug":"_6-3、调用运行时类中的指定构造器","link":"#_6-3、调用运行时类中的指定构造器","children":[]}]},{"level":2,"title":"07、反射的应用：动态代理","slug":"_07、反射的应用-动态代理","link":"#_07、反射的应用-动态代理","children":[{"level":3,"title":"7.1、代理模式与动态代理","slug":"_7-1、代理模式与动态代理","link":"#_7-1、代理模式与动态代理","children":[]},{"level":3,"title":"7.2、静态代理举例","slug":"_7-2、静态代理举例","link":"#_7-2、静态代理举例","children":[]},{"level":3,"title":"7.3、动态代理举例","slug":"_7-3、动态代理举例","link":"#_7-3、动态代理举例","children":[]},{"level":3,"title":"7.4、AOP与动态代理的举例","slug":"_7-4、aop与动态代理的举例","link":"#_7-4、aop与动态代理的举例","children":[]}]}],"git":{"createdTime":1685524601000,"updatedTime":1685524601000,"contributors":[{"name":"kirito","email":"2724964601@qq.com","commits":1}]},"readingTime":{"minutes":24.11,"words":7234},"filePathRelative":"notes/javacore/java/17、反射与动态代理.md","localizedDate":"2023年5月31日"}');export{l as data};
