const e=JSON.parse('{"key":"v-38d3105a","path":"/web/es6/22.Class%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95.html","title":"Class 的基本语法","lang":"zh-CN","frontmatter":{"title":"Class 的基本语法","category":["es6"],"tag":["ECMASCRIPT","javascript"],"sticky":false,"star":false,"article":true,"timeline":true,"description":"类的由来 JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。 上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。 ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。 基本上，ES6 的cl...","head":[["meta",{"property":"og:url","content":"https://Ragnarokoo.github.io/LearningNotes/web/es6/22.Class%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95.html"}],["meta",{"property":"og:site_name","content":"📚全栈开发学习指南"}],["meta",{"property":"og:title","content":"Class 的基本语法"}],["meta",{"property":"og:description","content":"类的由来 JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。 上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。 ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。 基本上，ES6 的cl..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2023-05-31T09:16:41.000Z"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:tag","content":"ECMASCRIPT"}],["meta",{"property":"article:tag","content":"javascript"}],["meta",{"property":"article:modified_time","content":"2023-05-31T09:16:41.000Z"}]]},"excerpt":"","headers":[{"level":2,"title":"类的由来","slug":"类的由来","link":"#类的由来","children":[]},{"level":2,"title":"constructor() 方法","slug":"constructor-方法","link":"#constructor-方法","children":[]},{"level":2,"title":"类的实例","slug":"类的实例","link":"#类的实例","children":[]},{"level":2,"title":"实例属性的新写法","slug":"实例属性的新写法","link":"#实例属性的新写法","children":[]},{"level":2,"title":"取值函数（getter）和存值函数（setter）","slug":"取值函数-getter-和存值函数-setter","link":"#取值函数-getter-和存值函数-setter","children":[]},{"level":2,"title":"属性表达式","slug":"属性表达式","link":"#属性表达式","children":[]},{"level":2,"title":"Class 表达式","slug":"class-表达式","link":"#class-表达式","children":[]},{"level":2,"title":"静态方法","slug":"静态方法","link":"#静态方法","children":[]},{"level":2,"title":"静态属性","slug":"静态属性","link":"#静态属性","children":[]},{"level":2,"title":"私有方法和私有属性","slug":"私有方法和私有属性","link":"#私有方法和私有属性","children":[{"level":3,"title":"早期解决方案","slug":"早期解决方案","link":"#早期解决方案","children":[]},{"level":3,"title":"私有属性的正式写法","slug":"私有属性的正式写法","link":"#私有属性的正式写法","children":[]},{"level":3,"title":"in 运算符","slug":"in-运算符","link":"#in-运算符","children":[]}]},{"level":2,"title":"静态块","slug":"静态块","link":"#静态块","children":[]},{"level":2,"title":"类的注意点","slug":"类的注意点","link":"#类的注意点","children":[{"level":3,"title":"严格模式","slug":"严格模式","link":"#严格模式","children":[]},{"level":3,"title":"不存在提升","slug":"不存在提升","link":"#不存在提升","children":[]},{"level":3,"title":"name 属性","slug":"name-属性","link":"#name-属性","children":[]},{"level":3,"title":"Generator 方法","slug":"generator-方法","link":"#generator-方法","children":[]},{"level":3,"title":"this 的指向","slug":"this-的指向","link":"#this-的指向","children":[]}]},{"level":2,"title":"new.target 属性","slug":"new-target-属性","link":"#new-target-属性","children":[]}],"git":{"createdTime":1685524601000,"updatedTime":1685524601000,"contributors":[{"name":"kirito","email":"2724964601@qq.com","commits":1}]},"readingTime":{"minutes":21.76,"words":6528},"filePathRelative":"web/es6/22.Class 的基本语法.md","localizedDate":"2023年5月31日"}');export{e as data};
