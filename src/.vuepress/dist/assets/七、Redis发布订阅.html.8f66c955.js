import{_ as s}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as r,c as n,d as e,e as t,b as l,a,r as c}from"./app.9b10ba0a.js";const p="/assets/2023-03-30-21-40-17-image.c9982b94.png",h="/assets/2023-03-30-21-41-13-image.346bef59.png",d="/assets/2023-03-30-21-41-44-image.55ef75b4.png",o="/assets/2023-03-30-21-43-14-image.7225cc22.png",u="/assets/2023-03-30-21-46-50-image.08c8d76b.png",b="/assets/2023-03-30-21-52-36-image.373d25d3.png",m="/assets/2023-03-30-21-54-34-image.820ba7b5.png",_="/assets/2023-03-30-21-55-56-image.2452a2e2.png",g="/assets/2023-03-30-22-03-55-image.ab8e3916.png",B="/assets/2023-03-30-22-06-01-image.b785619b.png",f="/assets/2023-03-30-22-06-33-image.86eaa436.png",S={},U=a('<h2 id="_01、学习定位" tabindex="-1"><a class="header-anchor" href="#_01、学习定位" aria-hidden="true">#</a> 01、学习定位</h2><p>了解即可</p><h2 id="_02、是什么" tabindex="-1"><a class="header-anchor" href="#_02、是什么" aria-hidden="true">#</a> 02、是什么？</h2><h3 id="定义" tabindex="-1"><a class="header-anchor" href="#定义" aria-hidden="true">#</a> 定义</h3><p>是一种消息通信模式：发送者（PUBLISH）发送消息，订阅者（SUBSCRIBE）接收消息，可以实现进程间的消息传递</p><h3 id="官网" tabindex="-1"><a class="header-anchor" href="#官网" aria-hidden="true">#</a> 官网</h3>',6),x={href:"https://redis.io/docs/manual/pubsub",target:"_blank",rel:"noopener noreferrer"},k=a('<h3 id="一句话" tabindex="-1"><a class="header-anchor" href="#一句话" aria-hidden="true">#</a> 一句话</h3><p>Redis可以实现消息中间件MQ的功能，通过发布订阅实现消息的引流和分流。</p><p>仅代表我个人，不推荐使用该功能，专业的事交给专业的中间件处理，redis就做好分布式缓存功能</p><h2 id="_03、能干嘛" tabindex="-1"><a class="header-anchor" href="#_03、能干嘛" aria-hidden="true">#</a> 03、能干嘛？</h2><ul><li>Redis客户端可以订阅任意数量的频道，类似我们微信关注多个公众号</li></ul><p><img src="'+p+'" alt=""></p><blockquote><p>当有新消息通过PUBLISH命令发送给频道channel1时</p></blockquote><p><img src="'+h+'" alt=""></p><ul><li>小总结</li></ul><p>发布/订阅其实是一个轻量的队列，只不过数据不会被持久化，一般用来处理实时性较高的异步消息</p><p><img src="'+d+'" alt=""></p><h2 id="_04、常用命令" tabindex="-1"><a class="header-anchor" href="#_04、常用命令" aria-hidden="true">#</a> 04、常用命令</h2><p><img src="'+o+'" alt=""></p><h3 id="subscribe-channel-channel" tabindex="-1"><a class="header-anchor" href="#subscribe-channel-channel" aria-hidden="true">#</a> SUBSCRIBE channel [channel ...]</h3><ul><li><p>订阅给定的一个或多个频道的信息</p></li><li><p><code>推荐先执行订阅后在发布，订阅成功之前发布的消息是收不到的</code></p></li><li><p>订阅的客户端每次可以收到一个3个参数的信息</p><ul><li><p>消息的种类</p></li><li><p>始发频道的名称</p></li><li><p>实际的消息内容</p></li><li><p><img src="'+u+'" alt=""></p></li></ul></li></ul><h3 id="publish-channel-message" tabindex="-1"><a class="header-anchor" href="#publish-channel-message" aria-hidden="true">#</a> PUBLISH channel message</h3><ul><li>发布消息到指定的频道</li></ul><h3 id="pubscribe-pattern-pattern" tabindex="-1"><a class="header-anchor" href="#pubscribe-pattern-pattern" aria-hidden="true">#</a> PUBSCRIBE pattern [pattern ...]</h3><ul><li>按照模式批量订阅，订阅一个或多个符合给定模式（支持*号?号之类的）的频道</li></ul><h3 id="pubsub-subcommand-argument-argument" tabindex="-1"><a class="header-anchor" href="#pubsub-subcommand-argument-argument" aria-hidden="true">#</a> PUBSUB subcommand [argument [argument ...]]</h3><ol><li><p>查看订阅与发布系统状态</p></li><li><p>PUBSUB CHANNELS</p></li></ol><ul><li><p>由活跃频道组成的列表</p></li><li><p>PUBSUB CHANNELS</p></li><li><p><img src="'+b+'" alt=""></p></li></ul><ol start="3"><li>PUBSUB NUMSUB [channel [channel...]]</li></ol><ul><li><p>某个频道有几个订阅者</p></li><li><p><img src="'+m+'" alt=""></p><ol start="4"><li>PUBSUB NUMPAT</li></ol></li></ul><blockquote><p>只统计使用PUBSCRIBE命令执行的，返回客户端订阅的<code>唯一模式的数量</code></p></blockquote><p><img src="'+_+'" alt=""></p><h3 id="unsubscribe-channel-channel" tabindex="-1"><a class="header-anchor" href="#unsubscribe-channel-channel" aria-hidden="true">#</a> UNSUBSCRIBE [channel [channel ...]]</h3><blockquote><p>取消订阅</p></blockquote><h3 id="punsubscribe-pattern-pattern" tabindex="-1"><a class="header-anchor" href="#punsubscribe-pattern-pattern" aria-hidden="true">#</a> PUNSUBSCRIBE [pattern [pattern...]]</h3><blockquote><p>退订所有给定模式的频道</p></blockquote><h2 id="_05、案例演示" tabindex="-1"><a class="header-anchor" href="#_05、案例演示" aria-hidden="true">#</a> 05、案例演示</h2><h3 id="当堂演示" tabindex="-1"><a class="header-anchor" href="#当堂演示" aria-hidden="true">#</a> 当堂演示</h3><ul><li>开启3个客户端，演示客户端A、B订阅消息，客户端C发布消息</li></ul><p><img src="'+g+'" alt=""></p><ul><li>演示批量订阅与发布</li></ul><p><img src="'+B+'" alt=""></p><ul><li>取消订阅</li></ul><p><img src="'+f+'" alt=""></p><h3 id="小总结" tabindex="-1"><a class="header-anchor" href="#小总结" aria-hidden="true">#</a> 小总结</h3><blockquote><p><code>Redis可以实现消息中间件MQ的功能，通过发布订阅实现消息的引导和分流。</code></p><p><code>仅仅代表我个人，不推荐使用该功能，专业的事情交给专业的中间件处理，redis就做好分布式缓存功能。</code></p></blockquote><blockquote><p><code>Pub/Sub缺点</code></p></blockquote><ul><li><p>发布的消息在Redis系统重不能持久化，因此，必须先执行订阅，再等待消息发布如果先发布了消息，那么该消息就没有订阅者，消息将被直接丢弃</p></li><li><p>消息只能发送对于发布者而言消息是即发即失的，不管接收，也没有ACK机制，无法保证消息的消费成功。</p></li><li><p>以上的缺点导致Redis的Pub/Sub模式就像个小玩具，在生产环境中几乎无用武之地，为此Redis5.0新增了Stream数据结构，不但支持多播，还支持数据持久化，相比Pub/Sub更加的强大</p></li></ul>',42);function P(R,q){const i=c("ExternalLinkIcon");return r(),n("div",null,[U,e("p",null,[e("a",x,[t("https://redis.io/docs/manual/pubsub"),l(i)])]),k])}const E=s(S,[["render",P],["__file","七、Redis发布订阅.html.vue"]]);export{E as default};
