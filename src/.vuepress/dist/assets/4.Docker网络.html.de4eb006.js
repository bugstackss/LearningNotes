import{_ as a}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as e,c as s,a as n}from"./app.9b10ba0a.js";const r="/assets/image-20230520224428724.d40869c1.png",p="/assets/image-20230520224554928.1f1bfeb9.png",i="/assets/image-20230520224630340.8740b393.png",t="/assets/image-20230520224710923.ef3a4b38.png",o="/assets/image-20230520224857688.fa1fa5f3.png",c="/assets/image-20230520225353878.c649da0c.png",l="/assets/image-20230520225424534.cdccdfc1.png",d="/assets/image-20230520225439510.8b7e09e4.png",m="/assets/image-20230520225458659.f0a94920.png",b="/assets/image-20230520225833691.29845eb7.png",u="/assets/image-20230520225819873.83d2cc3c.png",g="/assets/image-20230520225947030.99cce802.png",k="/assets/image-20230520230320276.6916f3a1.png",v="/assets/image-20230520230721892.5ba8acce.png",h="/assets/image-20230520231001936.0ba98054.png",_="/assets/image-20230520231118511.b13f17a6.png",f="/assets/image-20230520231448277.dd6d22c3.png",q="/assets/image-20230520231511931.d9987686.png",x="/assets/image-20230520231545822.01fdee30.png",w="/assets/image-20230520231732751.aab6a685.png",D="/assets/image-20230520232037246.4d284b42.png",I="/assets/image-20230520232113441.14c2ac4e.png",y="/assets/image-20230520232135185.843dfc34.png",P="/assets/image-20230520225631395.5438d401.png",j="/assets/image-20230520232505301.ed841419.png",L="/assets/image-20230520232516391.9bc9a1d0.png",N="/assets/image-20230520232539976.a1d3c4ff.png",C="/assets/image-20230520232550567.87da82c0.png",z="/assets/image-20230520232653839.d12ac112.png",A="/assets/image-20230520232850641.bde9b50c.png",X="/assets/image-20230520232858673.b48ad070.png",E="/assets/image-20230520225133500.f670bea8.png",O={},S=n('<h2 id="一、是什么" tabindex="-1"><a class="header-anchor" href="#一、是什么" aria-hidden="true">#</a> 一、是什么</h2><blockquote><p>docker不启动，默认网络情况</p></blockquote><p><img src="'+r+`" alt="image-20230520224428724"></p><ul><li>ens33</li><li>Io</li><li>virbr0</li></ul><p>在CentOS7的安装过程中如果有<code>选择相关虚拟化的的服务安装系统后</code>，启动网卡时会发现有一个以网桥连接的私网地址的virbr0网卡(virbr0网卡：它还有一个固定的默认IP地址192.168.122.1)，是做虚拟机网桥的使用的，其作用是为连接其上的虚机网卡提供 NAT访问外网的功能。</p><p>我们之前学习Linux安装，勾选安装系统的时候附带了libvirt服务才会生成的一个东西，如果不需要可以直接将libvirtd服务卸载，</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>yum remove libvirt-libs.x86_64
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>docker启动后，网络情况</p></blockquote><p><strong>会产生一个名为docker0的虚拟网桥</strong></p><p><img src="`+p+'" alt="image-20230520224554928"></p><p><strong>查看docker网络模式命令</strong></p><p>默认创建3大网络模式</p><p><img src="'+i+`" alt="image-20230520224630340"></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> network <span class="token function">ls</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="二、常用基本命令" tabindex="-1"><a class="header-anchor" href="#二、常用基本命令" aria-hidden="true">#</a> 二、常用基本命令</h2><blockquote><p>ALL命令</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> network <span class="token parameter variable">--help</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="`+t+`" alt="image-20230520224710923"></p><blockquote><p>查看网络</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> network <span class="token function">ls</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>查看网络源数据</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> network inspect XXX网络名字
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>删除网络</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> network <span class="token function">rm</span> XXX网络名字
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>案例</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> network create aa network
<span class="token function">docker</span> network <span class="token function">ls</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+o+'" alt="image-20230520224857688"></p><h2 id="三、能干嘛" tabindex="-1"><a class="header-anchor" href="#三、能干嘛" aria-hidden="true">#</a> 三、能干嘛</h2><ul><li>容器间的互联和通信以及端口映射</li><li>容器IP变动的时候可以通过服务名直接网络通信而不受到影响</li></ul><h2 id="四、网络模式" tabindex="-1"><a class="header-anchor" href="#四、网络模式" aria-hidden="true">#</a> 四、网络模式</h2><h3 id="总体介绍" tabindex="-1"><a class="header-anchor" href="#总体介绍" aria-hidden="true">#</a> 总体介绍</h3><p><img src="'+c+'" alt="image-20230520225353878"></p><ul><li>bridge模式：使用–network bridge指定，默认使用docker0</li><li>host模式：使用–network host指定</li><li>none模式：使用–netw none指定</li><li>container模式：使用–network container:NAME或者容器ID指定</li></ul><h3 id="容器实例内模式网络ip生产规则" tabindex="-1"><a class="header-anchor" href="#容器实例内模式网络ip生产规则" aria-hidden="true">#</a> 容器实例内模式网络IP生产规则</h3><blockquote><p>说明</p></blockquote><p>1 先启动两个ubuntu容器实例</p><p><img src="'+l+'" alt="image-20230520225424534"></p><p>2 docker inspect 容器ID or 容器名字</p><p><img src="'+d+'" alt="image-20230520225439510"></p><p>3 关闭u2实例，新建u3，查看ip变化</p><p><img src="'+m+`" alt="image-20230520225458659"></p><blockquote><p>结论</p><p>docker容器内部的IP是有可能会发生改变的</p></blockquote><h3 id="案例说明" tabindex="-1"><a class="header-anchor" href="#案例说明" aria-hidden="true">#</a> 案例说明</h3><h4 id="bridge" tabindex="-1"><a class="header-anchor" href="#bridge" aria-hidden="true">#</a> bridge</h4><blockquote><p>是什么</p></blockquote><p>Docker 服务默认会创建一个 docker0 网桥（其上有一个 docker0 内部接口），该桥接网络的名称为docker0，它在<strong>内核层</strong>连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到<strong>同一个物理网络</strong>。Docker 默认指定了 docker0 接口 的 IP 地址和子网掩码，<strong>让主机和容器之间可以通过网桥相互通信。</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 查看 bridge 网络的详细信息，并通过 grep 获取名称项</span>

<span class="token function">docker</span> network inspect bridge <span class="token operator">|</span> <span class="token function">grep</span> name
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+b+`" alt="image-20230520225833691"></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">ifconfig</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="`+u+'" alt="image-20230520225819873"></p><blockquote><p>案例</p></blockquote><p><strong>说明</strong></p><p>1 Docker使用Linux桥接，在宿主机虚拟一个Docker容器网桥(docker0)，Docker启动一个容器时会根据Docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的Container-IP直接通信。</p><p>2 docker run 的时候，没有指定network的话默认使用的网桥模式就是bridge，使用的就是docker0。在宿主机ifconfig,就可以看到docker0和自己create的network(后面讲)eth0，eth1，eth2……代表网卡一，网卡二，网卡三……，lo代表127.0.0.1，即localhost，inet addr用来表示网卡的IP地址</p><p>3 网桥docker0创建一对对等虚拟设备接口一个叫veth，另一个叫eth0，成对匹配。</p><p>3.1 整个宿主机的网桥模式都是docker0，类似一个交换机有一堆接口，每个接口叫veth，在本地主机和容器内分别创建一个虚拟接口，并让他们彼此联通（这样一对接口叫veth pair）；</p><p>3.2 每个容器实例内部也有一块网卡，每个接口叫eth0；</p><p>3.3 docker0上面的每个veth匹配某个容器实例内部的eth0，两两配对，一一匹配。</p><p>通过上述，将宿主机上的所有容器都连接到这个内部网络上，两个容器在同一个网络下,会从这个网关下各自拿到分配的ip，此时两个容器的网络是互通的。</p><p><img src="'+g+`" alt="image-20230520225947030"></p><p><strong>代码</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8081</span>:8080 <span class="token parameter variable">--name</span> tomcat81 billygoo/tomcat8-java-jdk8

<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8082</span>:8080 <span class="token parameter variable">--name</span> tomcat82 billygoo/tomcat8-java-jdk8
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>两两匹配验证</strong></p><p><img src="`+k+'" alt="image-20230520230320276"></p><h4 id="host" tabindex="-1"><a class="header-anchor" href="#host" aria-hidden="true">#</a> host</h4><blockquote><p>是什么</p></blockquote><p>直接使用宿主机的 IP 地址与外界进行通信，不再需要额外进行NAT 转换。</p><blockquote><p>案例</p></blockquote><p><strong>说明</strong></p><p>容器将<strong>不会获得</strong>一个独立的Network Namespace， 而是和宿主机共用一个Network Namespace。<strong>容器将不会虚拟出自己的网卡而是使用宿主机的IP和端口</strong>。</p><p><img src="'+v+`" alt="image-20230520230721892"></p><p><strong>代码</strong></p><p>⚠️警告</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8083</span>:8080 <span class="token parameter variable">--network</span> <span class="token function">host</span> <span class="token parameter variable">--name</span> tomcat83 billygoo/tomcat8-jdk8
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="`+h+`" alt="image-20230520231001936"></p><p>问题：</p><p>docke启动时总是遇见标题中的警告</p><p>原因：</p><p>docker启动时指定--network=host或-net=host，如果还指定了-p映射端口，那这个时候就会有此警告，并且通过-p设置的参数将不会起到任何作用，端口号会以主机端口号为主，重复时则递增。</p><p>解决:</p><p>解决的办法就是使用docker的其他网络模式，例如--network=bridge，这样就可以解决问题，或者直接无视。。。。O(∩_∩)O哈哈~</p><p>✅正确</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--network</span> <span class="token function">host</span> <span class="token parameter variable">--name</span> tomcat83 billygoo/tomcat8-jdk8
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>无之前的配置显示，看容器示例内部</strong></p><p><img src="`+_+`" alt="image-20230520231118511"></p><p><strong>没有设置 -p的端口映射了，如何访问启动的tomcat83？？</strong></p><div class="language-http line-numbers-mode" data-ext="http"><pre class="language-http"><code><span class="token header"><span class="token header-name keyword">http</span><span class="token punctuation">:</span><span class="token header-value">//宿主机IP:8080/</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在CentOS里面用默认的火狐浏览器访问容器内的tomcat83看到访问成功，因为此时容器的IP借用主机的，</p><p>所以容器共享宿主机网络IP，这样的好处是外部主机与容器可以直接通信。</p><h4 id="none" tabindex="-1"><a class="header-anchor" href="#none" aria-hidden="true">#</a> none</h4><blockquote><p>是什么</p></blockquote><p>在none模式下，并不为Docker容器进行任何网络配置。</p><p>也就是说，这个Docker容器没有网卡、IP、路由等信息，只有一个lo</p><p>需要我们自己为Docker容器添加网卡、配置IP等。</p><p><strong>禁用网络功能，只有Io标识（就是127.0.0.1表示本地回环）</strong></p><blockquote><p>案例</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8084</span>:8080 <span class="token parameter variable">--network</span> none <span class="token parameter variable">--name</span> tomcat84 billygoo/tomcat8-jdk8
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>进入容器内部查看</p><p><img src="`+f+'" alt="image-20230520231448277"></p><p>在容器外部查看</p><p><img src="'+q+`" alt="image-20230520231511931"></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8084</span>:8080 <span class="token parameter variable">--network</span> none <span class="token parameter variable">--name</span> tomcat84 billygpp/tomcat8-jdk8
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="container" tabindex="-1"><a class="header-anchor" href="#container" aria-hidden="true">#</a> container</h4><blockquote><p>是什么</p></blockquote><p>container⽹络模式</p><p>新建的容器和已经存在的一个容器共享一个网络ip配置而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。</p><p><img src="`+x+`" alt="image-20230520231545822"></p><blockquote><p>❌案例</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8085</span>:8080 <span class="token parameter variable">--name</span> tomcat85 billygoo-tomcat8-jdk8

<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8086</span>:8080 <span class="token parameter variable">--network</span> container:tomcat85 <span class="token parameter variable">--name</span> tomcat85 billygoo-tomcat8-jdk8
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+w+`" alt="image-20230520231732751"></p><p># 相当于tomcat86和tomcat85公用同一个ip同一个端口，导致端口冲突</p><p>本案例用tomcat演示不合适。。。演示坑。。。。。。o(╥﹏╥)o</p><p>换一个镜像给大家演示，</p><hr><blockquote><p>✅案例2</p></blockquote><p>Alpine操作系统是一个面向安全的轻型Linux发行版</p><p>Alpine Linux 是一款独立的、非商业的通用 Linux 发行版，专为追求安全性、简单性和资源效率的用户而设计。 可能很多人没听说过这个 Linux 发行版本，但是经常用 Docker 的朋友可能都用过，因为他小，简单，安全而著称，所以作为基础镜像是非常好的一个选择，可谓是麻雀虽小但五脏俱全，镜像非常小巧，不到 6M的大小，所以特别适合容器打包。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--name</span> alpine1 alpine /bin/sh

<span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--network</span> container:alpine1 <span class="token parameter variable">--name</span> alpine1 alpine /bin/sh
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行结果，验证共用搭桥</p><p><img src="`+D+'" alt="image-20230520232037246"></p><p>假如此时关闭alpine1，在看看alpine2</p><p><img src="'+I+'" alt="image-20230520232113441"></p><p>15: eth0@if16: 消失了。。。。。。关闭alpine1，再看看alpine2</p><p><img src="'+y+'" alt="image-20230520232135185"></p><h4 id="自定义网络" tabindex="-1"><a class="header-anchor" href="#自定义网络" aria-hidden="true">#</a> 自定义网络</h4><blockquote><p>过时的link</p></blockquote><p><img src="'+P+`" alt="image-20230520225631395"></p><blockquote><p>是什么</p></blockquote><blockquote><p>案例</p></blockquote><ul><li>before</li></ul><p><strong>案例</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8081</span>:8080 <span class="token parameter variable">--name</span> tomcat81 billygoo/tomcat8-jdk8

<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8082</span>:8080 <span class="token parameter variable">--name</span> tomcat82 billygoo/tomcat8-jdk8
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述成功启动并用docker exec进入各自容器实例内部</p><p><strong>问题</strong></p><p>按照IP地址ping是OK的</p><p><img src="`+j+'" alt="image-20230520232505301"></p><p><img src="'+L+'" alt="image-20230520232516391"></p><p>按照服务名ping结果？？？</p><p><img src="'+N+'" alt="image-20230520232539976"></p><p><img src="'+C+`" alt="image-20230520232550567"></p><ul><li>after</li></ul><p><strong>案例</strong></p><p>1.自定义桥接网络，自定义网络默认使用的是桥接网络bridge</p><p>2.新建自定义网络</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> network <span class="token function">ls</span>

<span class="token function">docker</span> network create zzyy_network
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+z+`" alt="image-20230520232653839"></p><p>3.新建容器加入上一步新建的自定义网络</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8081</span>:8080 <span class="token parameter variable">--network</span> zzyy_network <span class="token parameter variable">--name</span> tomcat81 billygoo/tomcat8-jdk8

<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8082</span>:8080 <span class="token parameter variable">--network</span> zzyy_network <span class="token parameter variable">--name</span> tomcat82 billygoo/tomcat8-jdk8
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>4.互相ping测试</p><p><img src="`+A+'" alt="image-20230520232850641"></p><p><img src="'+X+'" alt="image-20230520232858673"></p><blockquote><p>问题结论</p><p>自定义网络本身就维护好了主机名和ip的对应关系（ip和域名都能通）</p><p>自定义网络本身就维护好了主机名和ip的对应关系（ip和域名都能通）</p><p>自定义网络本身就维护好了主机名和ip的对应关系（ip和域名都能通）</p></blockquote><h2 id="五、docker平台架构图解" tabindex="-1"><a class="header-anchor" href="#五、docker平台架构图解" aria-hidden="true">#</a> 五、Docker平台架构图解</h2><blockquote><p>整体说明</p></blockquote><p>从其架构和运行流程来看，Docker 是一个 C/S 模式的架构，后端是一个松耦合架构，众多模块各司其职。</p><p>Docker 运行的基本流程为：</p><p>1 用户是使用 Docker Client 与 Docker Daemon 建立通信，并发送请求给后者。</p><p>2 Docker Daemon 作为 Docker 架构中的主体部分，首先提供 Docker Server 的功能使其可以接受 Docker Client 的请求。</p><p>3 Docker Engine 执行 Docker 内部的一系列工作，每一项工作都是以一个 Job 的形式的存在。</p><p>4 Job 的运行过程中，当需要容器镜像时，则从 Docker Registry 中下载镜像，并通过镜像管理驱动 Graph driver将下载镜像以Graph的形式存储。</p><p>5 当需要为 Docker 创建网络环境时，通过网络管理驱动 Network driver 创建并配置 Docker 容器网络环境。</p><p>6 当需要限制 Docker 容器运行资源或执行用户指令等操作时，则通过 Execdriver 来完成。</p><p>7 Libcontainer是一项独立的容器管理包，Network driver以及Exec driver都是通过Libcontainer来实现具体对容器进行的操作。</p><blockquote><p>整体流程</p></blockquote><p><img src="'+E+'" alt="image-20230520225133500"></p>',165),B=[S];function G(J,M){return e(),s("div",null,B)}const R=a(O,[["render",G],["__file","4.Docker网络.html.vue"]]);export{R as default};
