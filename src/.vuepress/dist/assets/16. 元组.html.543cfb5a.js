const t=JSON.parse('{"key":"v-47ada843","path":"/web/ts/16.%20%E5%85%83%E7%BB%84.html","title":"元组","lang":"zh-CN","frontmatter":{"title":"元组","category":["ts"],"tag":["typescript","javascript"],"sticky":false,"star":false,"article":true,"timeline":true,"description":"数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象。 元组起源于函数编程语言（如 F#），这些语言中会频繁使用元组。 简单的例子 定义一对值分别为 string 和 number 的元组： 当赋值或访问一个已知索引的元素时，会得到正确的类型： 也可以只赋值其中一项： 但是当直接对元组类型的变量进行初始化或者赋值的时候，需要提供所有元组类...","head":[["meta",{"property":"og:url","content":"https://Ragnarokoo.github.io/LearningNotes/web/ts/16.%20%E5%85%83%E7%BB%84.html"}],["meta",{"property":"og:site_name","content":"📚全栈开发学习指南"}],["meta",{"property":"og:title","content":"元组"}],["meta",{"property":"og:description","content":"数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象。 元组起源于函数编程语言（如 F#），这些语言中会频繁使用元组。 简单的例子 定义一对值分别为 string 和 number 的元组： 当赋值或访问一个已知索引的元素时，会得到正确的类型： 也可以只赋值其中一项： 但是当直接对元组类型的变量进行初始化或者赋值的时候，需要提供所有元组类..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2023-05-31T09:16:41.000Z"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:tag","content":"typescript"}],["meta",{"property":"article:tag","content":"javascript"}],["meta",{"property":"article:modified_time","content":"2023-05-31T09:16:41.000Z"}]]},"excerpt":"","headers":[{"level":2,"title":"简单的例子","slug":"简单的例子","link":"#简单的例子","children":[]},{"level":2,"title":"越界的元素","slug":"越界的元素","link":"#越界的元素","children":[]},{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]}],"git":{"createdTime":1685524601000,"updatedTime":1685524601000,"contributors":[{"name":"kirito","email":"2724964601@qq.com","commits":1}]},"readingTime":{"minutes":1.29,"words":387},"filePathRelative":"web/ts/16. 元组.md","localizedDate":"2023年5月31日"}');export{t as data};
