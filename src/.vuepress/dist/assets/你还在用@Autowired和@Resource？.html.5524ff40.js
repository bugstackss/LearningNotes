import{_ as o}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as c,c as t,d as s,e as n,b as l,a as e,r as i}from"./app.9b10ba0a.js";const p={},r=e(`<p>直接上总结：<code>我们在类上使用 Lombok的@RequiredArgsConstructor 注解来替代类中的多处@Autowired和@Resource</code>。</p><h3 id="依赖注入" tabindex="-1"><a class="header-anchor" href="#依赖注入" aria-hidden="true">#</a> 依赖注入</h3><p>先回顾一下Spring的3种依赖注入。</p><ol><li>属性注入</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SysUserController</span> <span class="token keyword">extends</span> <span class="token class-name">BaseController</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">ISysUserService</span> userService<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Resource</span>
    <span class="token keyword">private</span> <span class="token class-name">ISysRoleService</span> roleService<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>@Autowired默认按类型装配,@Resource默认按名称装配，当找不到与名称匹配的bean时，才会按类型装配。</p><p>而@Qualifier和Autowired配合使用，指定bean的名称，也可以做到按名称装配。</p><p>IDEA中直接在变量上使用 @Autowired会发现警告提示：<code>Field injection is not recommended</code>。</p><p>原因是官方建议我们使用构造器注入方式，这种方式存在明显的弊端，比如：注入对象不能用final修饰、无法发现NullPointException的存在。</p><ol start="2"><li>构造器注入</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SysUserController</span> <span class="token keyword">extends</span> <span class="token class-name">BaseController</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ISysUserService</span> userService<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ISysRoleService</span> roleService<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">SysUserController</span><span class="token punctuation">(</span><span class="token class-name">ISysUserService</span> userService<span class="token punctuation">,</span> <span class="token class-name">ISysRoleService</span> roleService<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>userService <span class="token operator">=</span> userService<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>roleService <span class="token operator">=</span> roleService<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>构造器依赖注入通过容器触发一个类的构造器来实现的，通过强制指明依赖注入来保证这个类的运行，防止<code>NullPointerException</code>；</p><p>Spring官方推荐使用构造器注入不仅是因为这种情况下成员属性可以使用final关键字修饰，更关键的一点是能够避免循环依赖，如果存在循环依赖，Spring项目启动的时候就会报错。</p><p>为什么说是避免而不是解决呢？</p><p><code>因为构造器注入是通过构造方法来生成对象，其必须要先获取属性，才能生成调用构造方法进行实例化，这种情况的循环依赖是无法解决的。</code></p><p>下面通过一张图来看下A、B俩相互依赖的对象注入方式不同时Spring能否解决循环依赖的情况：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eab81918af7946328f5d24fb60652d0c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p>`,17),d=s("br",null,null,-1),u=s("br",null,null,-1),v=s("br",null,null,-1),k=s("br",null,null,-1),m={href:"https://link.juejin.cn/?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F562691467",title:"https://link.juejin.cn/?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F562691467",target:"_blank",rel:"noopener noreferrer"},b=e(`<ol start="3"><li>Setter注入</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SysUserController</span> <span class="token keyword">extends</span> <span class="token class-name">BaseController</span> <span class="token punctuation">{</span>
    
    <span class="token keyword">private</span> <span class="token class-name">ISysUserService</span> userService<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUserService</span><span class="token punctuation">(</span><span class="token class-name">ISysUserService</span> userService<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>userService <span class="token operator">=</span> userService<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>需要注意的是，在使用Setter注入时需要加<code>@Autowired</code>或<code>@Resource</code>注解，否则是无法注入成功的。</p><p>另外要注意一点，属性注入和Setter注入的变量都无法使用<code>final</code>关键字修饰。</p><h3 id="requiredargsconstructor" tabindex="-1"><a class="header-anchor" href="#requiredargsconstructor" aria-hidden="true">#</a> @RequiredArgsConstructor</h3><blockquote><p>这里可能会有人说不推荐使用Lombok，只要我们知其然且知其所以然，那他就是一个帮助我们快速开发的好工具。</p></blockquote><p>在说完Spring的三种依赖注入后，我们来认识一下Lombok的@RequiredArgsConstructor 注解。</p><p>在Lombok中，生成构造方法的注解一共有三个，分别是@NoArgsConstructor, @RequiredArgsConstructor, @AllArgsContructor，我们这里只介绍@RequiredArgsConstructor。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Controller</span>
<span class="token annotation punctuation">@RequiredArgsConstructor</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SysUserController</span> <span class="token keyword">extends</span> <span class="token class-name">BaseController</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ISysUserService</span> userService<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">ISysRoleService</span> roleService<span class="token punctuation">;</span>

   <span class="token comment">//----------------------------</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用@RequiredArgsConstructor会为我们生成一个包含<code>常量、使用final关键字修饰的变量</code>的<code>私有构造方法</code>。</p><p>那我们就可以不使用属性注入(@Autowired和@Resource)的方式，直接通过构造器的方式来完成注入，不仅能够省略简化许多代码，也解决了属性注入可能存在的空指针问题。</p>`,11);function S(y,h){const a=i("ExternalLinkIcon");return c(),t("div",null,[r,s("blockquote",null,[s("p",null,[n("构造器注入方式解决循环依赖:"),d,n(" 1.代码重构"),u,n(" 2.@Lazy注解"),v,n(" 3.改用属性注入"),k,n(" 建议查看："),s("a",m,[n("zhuanlan.zhihu.com"),l(a)])])]),b])}const _=o(p,[["render",S],["__file","你还在用@Autowired和@Resource？.html.vue"]]);export{_ as default};
